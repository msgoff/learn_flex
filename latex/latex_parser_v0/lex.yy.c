
#line 3 "lex.yy.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 3
#define YY_END_OF_BUFFER 4
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[16] =
    {   0,
        0,    0,    4,    2,    3,    2,    0,    0,    0,    0,
        0,    0,    0,    1,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    1,    1,    1,    1,    1,    1,    1,    1,

        4,    1,    1,    1,    5,    1,    1,    6,    1,    1,
        1,    1,    1,    1,    1,    7,    1,    1,    1,    1,
        1,    1,    8,    1,    9,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[10] =
    {   0,
        1,    2,    1,    1,    1,    1,    1,    1,    1
    } ;

static const flex_int16_t yy_base[18] =
    {   0,
        0,    2,   18,   19,   19,   10,   11,    8,    8,    9,
        4,    2,    1,    0,   19,    5,    0
    } ;

static const flex_int16_t yy_def[18] =
    {   0,
       16,   16,   15,   15,   15,   15,   15,   15,   15,   15,
       15,   17,   17,   17,    0,   15,   15
    } ;

static const flex_int16_t yy_nxt[29] =
    {   0,
       13,    5,    6,    5,    6,    4,    4,   15,   14,   14,
       14,   12,   11,   10,    9,    8,    7,   15,    3,   15,
       15,   15,   15,   15,   15,   15,   15,   15
    } ;

static const flex_int16_t yy_chk[29] =
    {   0,
       17,    1,    1,    2,    2,   16,   16,    0,   14,   13,
       12,   11,   10,    9,    8,    7,    6,    3,   15,   15,
       15,   15,   15,   15,   15,   15,   15,   15
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "latex_repl.l"
#line 2 "latex_repl.l"
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

int print_unicode(wchar_t unicode) {
    setlocale(LC_CTYPE, "");
    wprintf(L"%lc", unicode);
}


#line 459 "lex.yy.c"
#line 460 "lex.yy.c"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals ( void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

			int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT
    
    static void yyunput ( int c, char *buf_ptr  );
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 14 "latex_repl.l"


#line 680 "lex.yy.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 16 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 19 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 16 "latex_repl.l"
ECHO ;
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 18 "latex_repl.l"
; 
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 19 "latex_repl.l"
ECHO;
	YY_BREAK
#line 752 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 16 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 16 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 15);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr )
{
    
	return yy_scan_bytes( yystr, (int) strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg )
{
			fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
    
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 * 
 */
void yyset_lineno (int  _line_number )
{
    
    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 19 "latex_repl.l"

/*

\\newline ;
\\author"{".*"}" ECHO  ;
\\date"{".*"}" ECHO ;
\address"{" ;
\\indent ;
\\email"{".*"}" ECHO ;
\\thanks"{".*"}" ECHO ;
\\keywords"{".*"}" ECHO ;
\\subjclass"{".*"}" ECHO ;
\nl {printf("\n");}
test {print_unicode(0x2605);}
\\mathexclam	{ print_unicode(0x2605); }
\\mathoctothorpe	{  print_unicode(0x0023); }
\\mathdollar	{  print_unicode(0x0024); }
\\mathpercent	{  print_unicode(0x0025); }
\\mathampersand	{  print_unicode(0x0026); }
\\lparen	{  print_unicode(0x0028); }
\\rparen	{  print_unicode(0x0029); }
\\mathplus	{  print_unicode(0x002B); }
\\mathcomma	{  print_unicode(0x002C); }
\\mathperiod	{  print_unicode(0x002E); }
\\mathslash	{  print_unicode(0x002F); }
\\mathcolon	{  print_unicode(0x003A); }
\\mathsemicolon	{  print_unicode(0x003B); }
\\less	{  print_unicode(0x003C); }
\\equal	{  print_unicode(0x003D); }
\\greater	{  print_unicode(0x003E); }
\\mathquestion	{  print_unicode(0x003F); }
\\mathatsign	{  print_unicode(0x0040); }
\\lbrack	{  print_unicode(0x005B); }
\\backslash	{  print_unicode(0x005C); }
\\rbrack	{  print_unicode(0x005D); }
\\lbrace	{  print_unicode(0x007B); }
\\vert	{  print_unicode(0x007C); }
\\rbrace	{  print_unicode(0x007D); }
\\mathsterling	{  print_unicode(0x00A3); }
\\mathyen	{  print_unicode(0x00A5); }
\\mathsection	{  print_unicode(0x00A7); }
\\neg	{  print_unicode(0x00AC); }
\\pm	{  print_unicode(0x00B1); }
\\mathparagraph	{  print_unicode(0x00B6); }
\\cdotp	{  print_unicode(0x00B7); }
\\times	{  print_unicode(0x00D7); }
\\matheth	{  print_unicode(0x00F0); }
\\div	{  print_unicode(0x00F7); }
\\Zbar	{  print_unicode(0x01B5); }
\\grave	{  print_unicode(0x0300); }
\\acute	{  print_unicode(0x0301); }
\\hat	{  print_unicode(0x0302); }
\\widehat	{  print_unicode(0x0302); }
\\tilde	{  print_unicode(0x0303); }
\\widetilde	{  print_unicode(0x0303); }
\\bar	{  print_unicode(0x0304); }
\\overbar	{  print_unicode(0x0305); }
\\wideoverbar	{  print_unicode(0x0305); }
\\breve	{  print_unicode(0x0306); }
\\widebreve	{  print_unicode(0x0306); }
\\dot	{  print_unicode(0x0307); }
\\ddot	{  print_unicode(0x0308); }
\\ovhook	{  print_unicode(0x0309); }
\\ocirc	{  print_unicode(0x030A); }
\\check	{  print_unicode(0x030C); }
\\widecheck	{  print_unicode(0x030C); }
\\candra	{  print_unicode(0x0310); }
\\oturnedcomma	{  print_unicode(0x0312); }
\\ocommatopright	{  print_unicode(0x0315); }
\\droang	{  print_unicode(0x031A); }
\\wideutilde	{  print_unicode(0x0330); }
\\mathunderbar	{  print_unicode(0x0332); }
\\notaccent	{  print_unicode(0x0338); }
\\underleftrightarrow	{  print_unicode(0x034D); }
\\mupAlpha	{  print_unicode(0x0391); }
\\mupBeta	{  print_unicode(0x0392); }
\\mupGamma	{  print_unicode(0x0393); }
\\mupDelta	{  print_unicode(0x0394); }
\\mupEpsilon	{  print_unicode(0x0395); }
\\mupZeta	{  print_unicode(0x0396); }
\\mupEta	{  print_unicode(0x0397); }
\\mupTheta	{  print_unicode(0x0398); }
\\mupIota	{  print_unicode(0x0399); }
\\mupKappa	{  print_unicode(0x039A); }
\\mupLambda	{  print_unicode(0x039B); }
\\mupMu	{  print_unicode(0x039C); }
\\mupNu	{  print_unicode(0x039D); }
\\mupXi	{  print_unicode(0x039E); }
\\mupOmicron	{  print_unicode(0x039F); }
\\mupPi	{  print_unicode(0x03A0); }
\\mupRho	{  print_unicode(0x03A1); }
\\mupSigma	{  print_unicode(0x03A3); }
\\mupTau	{  print_unicode(0x03A4); }
\\mupUpsilon	{  print_unicode(0x03A5); }
\\mupPhi	{  print_unicode(0x03A6); }
\\mupChi	{  print_unicode(0x03A7); }
\\mupPsi	{  print_unicode(0x03A8); }
\\mupOmega	{  print_unicode(0x03A9); }
\\mupalpha	{  print_unicode(0x03B1); }
\\mupbeta	{  print_unicode(0x03B2); }
\\mupgamma	{  print_unicode(0x03B3); }
\\mupdelta	{  print_unicode(0x03B4); }
\\mupvarepsilon	{  print_unicode(0x03B5); }
\\mupzeta	{  print_unicode(0x03B6); }
\\mupeta	{  print_unicode(0x03B7); }
\\muptheta	{  print_unicode(0x03B8); }
\\mupiota	{  print_unicode(0x03B9); }
\\mupkappa	{  print_unicode(0x03BA); }
\\muplambda	{  print_unicode(0x03BB); }
\\mupmu	{  print_unicode(0x03BC); }
\\mupnu	{  print_unicode(0x03BD); }
\\mupxi	{  print_unicode(0x03BE); }
\\mupomicron	{  print_unicode(0x03BF); }
\\muppi	{  print_unicode(0x03C0); }
\\muprho	{  print_unicode(0x03C1); }
\\mupvarsigma	{  print_unicode(0x03C2); }
\\mupsigma	{  print_unicode(0x03C3); }
\\muptau	{  print_unicode(0x03C4); }
\\mupupsilon	{  print_unicode(0x03C5); }
\\mupvarphi	{  print_unicode(0x03C6); }
\\mupchi	{  print_unicode(0x03C7); }
\\muppsi	{  print_unicode(0x03C8); }
\\mupomega	{  print_unicode(0x03C9); }
\\mupvartheta	{  print_unicode(0x03D1); }
\\mupphi	{  print_unicode(0x03D5); }
\\mupvarpi	{  print_unicode(0x03D6); }
\\upDigamma	{  print_unicode(0x03DC); }
\\updigamma	{  print_unicode(0x03DD); }
\\mupvarkappa	{  print_unicode(0x03F0); }
\\mupvarrho	{  print_unicode(0x03F1); }
\\mupvarTheta	{  print_unicode(0x03F4); }
\\mupepsilon	{  print_unicode(0x03F5); }
\\upbackepsilon	{  print_unicode(0x03F6); }
\\mathhyphen	{  print_unicode(0x2010); }
\\horizbar	{  print_unicode(0x2015); }
\\Vert	{  print_unicode(0x2016); }
\\twolowline	{  print_unicode(0x2017); }
\\dagger	{  print_unicode(0x2020); }
\\ddagger	{  print_unicode(0x2021); }
\\smblkcircle	{  print_unicode(0x2022); }
\\enleadertwodots	{  print_unicode(0x2025); }
\\unicodeellipsis	{  print_unicode(0x2026); }
\\prime	{  print_unicode(0x2032); }
\\dprime	{  print_unicode(0x2033); }
\\trprime	{  print_unicode(0x2034); }
\\backprime	{  print_unicode(0x2035); }
\\backdprime	{  print_unicode(0x2036); }
\\backtrprime	{  print_unicode(0x2037); }
\\caretinsert	{  print_unicode(0x2038); }
\\Exclam	{  print_unicode(0x203C); }
\\tieconcat	{  print_unicode(0x2040); }
\\hyphenbullet	{  print_unicode(0x2043); }
\\fracslash	{  print_unicode(0x2044); }
\\Question	{  print_unicode(0x2047); }
\\closure	{  print_unicode(0x2050); }
\\qprime	{  print_unicode(0x2057); }
\\euro	{  print_unicode(0x20AC); }
\\leftharpoonaccent	{  print_unicode(0x20D0); }
\\overleftharpoon	{  print_unicode(0x20D0); }
\\rightharpoonaccent	{  print_unicode(0x20D1); }
\\overrightharpoon	{  print_unicode(0x20D1); }
\\vertoverlay	{  print_unicode(0x20D2); }
\\overleftarrow	{  print_unicode(0x20D6); }
\\overrightarrow	{  print_unicode(0x20D7); }
\\vec	{  print_unicode(0x20D7); }
\\dddot	{  print_unicode(0x20DB); }
\\ddddot	{  print_unicode(0x20DC); }
\\enclosecircle	{  print_unicode(0x20DD); }
\\enclosesquare	{  print_unicode(0x20DE); }
\\enclosediamond	{  print_unicode(0x20DF); }
\\overleftrightarrow	{  print_unicode(0x20E1); }
\\enclosetriangle	{  print_unicode(0x20E4); }
\\annuity	{  print_unicode(0x20E7); }
\\threeunderdot	{  print_unicode(0x20E8); }
\\widebridgeabove	{  print_unicode(0x20E9); }
\\underrightharpoondown	{  print_unicode(0x20EC); }
\\underleftharpoondown	{  print_unicode(0x20ED); }
\\underleftarrow	{  print_unicode(0x20EE); }
\\underrightarrow	{  print_unicode(0x20EF); }
\\asteraccent	{  print_unicode(0x20F0); }
\\BbbC	{  print_unicode(0x2102); }
\\Eulerconst	{  print_unicode(0x2107); }
\\mscrg	{  print_unicode(0x210A); }
\\mscrH	{  print_unicode(0x210B); }
\\mfrakH	{  print_unicode(0x210C); }
\\BbbH	{  print_unicode(0x210D); }
\\Planckconst	{  print_unicode(0x210E); }
\\hslash	{  print_unicode(0x210F); }
\\mscrI	{  print_unicode(0x2110); }
\\Im	{  print_unicode(0x2111); }
\\mscrL	{  print_unicode(0x2112); }
\\ell	{  print_unicode(0x2113); }
\\BbbN	{  print_unicode(0x2115); }
\\wp	{  print_unicode(0x2118); }
\\BbbP	{  print_unicode(0x2119); }
\\BbbQ	{  print_unicode(0x211A); }
\\mscrR	{  print_unicode(0x211B); }
\\Re	{  print_unicode(0x211C); }
\\BbbR	{  print_unicode(0x211D); }
\\BbbZ	{  print_unicode(0x2124); }
\\mho	{  print_unicode(0x2127); }
\\mfrakZ	{  print_unicode(0x2128); }
\\turnediota	{  print_unicode(0x2129); }
\\Angstrom	{  print_unicode(0x212B); }
\\mscrB	{  print_unicode(0x212C); }
\\mfrakC	{  print_unicode(0x212D); }
\\mscre	{  print_unicode(0x212F); }
\\mscrE	{  print_unicode(0x2130); }
\\mscrF	{  print_unicode(0x2131); }
\\Finv	{  print_unicode(0x2132); }
\\mscrM	{  print_unicode(0x2133); }
\\mscro	{  print_unicode(0x2134); }
\\aleph	{  print_unicode(0x2135); }
\\beth	{  print_unicode(0x2136); }
\\gimel	{  print_unicode(0x2137); }
\\daleth	{  print_unicode(0x2138); }
\\Bbbpi	{  print_unicode(0x213C); }
\\Bbbgamma	{  print_unicode(0x213D); }
\\BbbGamma	{  print_unicode(0x213E); }
\\BbbPi	{  print_unicode(0x213F); }
\\Bbbsum	{  print_unicode(0x2140); }
\\Game	{  print_unicode(0x2141); }
\\sansLturned	{  print_unicode(0x2142); }
\\sansLmirrored	{  print_unicode(0x2143); }
\\Yup	{  print_unicode(0x2144); }
\\mitBbbD	{  print_unicode(0x2145); }
\\mitBbbd	{  print_unicode(0x2146); }
\\mitBbbe	{  print_unicode(0x2147); }
\\mitBbbi	{  print_unicode(0x2148); }
\\mitBbbj	{  print_unicode(0x2149); }
\\PropertyLine	{  print_unicode(0x214A); }
\\upand	{  print_unicode(0x214B); }
\\leftarrow	{  print_unicode(0x2190); }
\\uparrow	{  print_unicode(0x2191); }
\\rightarrow	{  print_unicode(0x2192); }
\\downarrow	{  print_unicode(0x2193); }
\\leftrightarrow	{  print_unicode(0x2194); }
\\updownarrow	{  print_unicode(0x2195); }
\\nwarrow	{  print_unicode(0x2196); }
\\nearrow	{  print_unicode(0x2197); }
\\searrow	{  print_unicode(0x2198); }
\\swarrow	{  print_unicode(0x2199); }
\\nleftarrow	{  print_unicode(0x219A); }
\\nrightarrow	{  print_unicode(0x219B); }
\\leftwavearrow	{  print_unicode(0x219C); }
\\rightwavearrow	{  print_unicode(0x219D); }
\\twoheadleftarrow	{  print_unicode(0x219E); }
\\twoheaduparrow	{  print_unicode(0x219F); }
\\twoheadrightarrow	{  print_unicode(0x21A0); }
\\twoheaddownarrow	{  print_unicode(0x21A1); }
\\leftarrowtail	{  print_unicode(0x21A2); }
\\rightarrowtail	{  print_unicode(0x21A3); }
\\mapsfrom	{  print_unicode(0x21A4); }
\\mapsup	{  print_unicode(0x21A5); }
\\mapsto	{  print_unicode(0x21A6); }
\\mapsdown	{  print_unicode(0x21A7); }
\\updownarrowbar	{  print_unicode(0x21A8); }
\\hookleftarrow	{  print_unicode(0x21A9); }
\\hookrightarrow	{  print_unicode(0x21AA); }
\\looparrowleft	{  print_unicode(0x21AB); }
\\looparrowright	{  print_unicode(0x21AC); }
\\leftrightsquigarrow	{  print_unicode(0x21AD); }
\\nleftrightarrow	{  print_unicode(0x21AE); }
\\downzigzagarrow	{  print_unicode(0x21AF); }
\\Lsh	{  print_unicode(0x21B0); }
\\Rsh	{  print_unicode(0x21B1); }
\\Ldsh	{  print_unicode(0x21B2); }
\\Rdsh	{  print_unicode(0x21B3); }
\\linefeed	{  print_unicode(0x21B4); }
\\carriagereturn	{  print_unicode(0x21B5); }
\\curvearrowleft	{  print_unicode(0x21B6); }
\\curvearrowright	{  print_unicode(0x21B7); }
\\barovernorthwestarrow	{  print_unicode(0x21B8); }
\\barleftarrowrightarrowbar	{  print_unicode(0x21B9); }
\\acwopencirclearrow	{  print_unicode(0x21BA); }
\\cwopencirclearrow	{  print_unicode(0x21BB); }
\\leftharpoonup	{  print_unicode(0x21BC); }
\\leftharpoondown	{  print_unicode(0x21BD); }
\\upharpoonright	{  print_unicode(0x21BE); }
\\upharpoonleft	{  print_unicode(0x21BF); }
\\rightharpoonup	{  print_unicode(0x21C0); }
\\rightharpoondown	{  print_unicode(0x21C1); }
\\downharpoonright	{  print_unicode(0x21C2); }
\\downharpoonleft	{  print_unicode(0x21C3); }
\\rightleftarrows	{  print_unicode(0x21C4); }
\\updownarrows	{  print_unicode(0x21C5); }
\\leftrightarrows	{  print_unicode(0x21C6); }
\\leftleftarrows	{  print_unicode(0x21C7); }
\\upuparrows	{  print_unicode(0x21C8); }
\\rightrightarrows	{  print_unicode(0x21C9); }
\\downdownarrows	{  print_unicode(0x21CA); }
\\leftrightharpoons	{  print_unicode(0x21CB); }
\\rightleftharpoons	{  print_unicode(0x21CC); }
\\nLeftarrow	{  print_unicode(0x21CD); }
\\nLeftrightarrow	{  print_unicode(0x21CE); }
\\nRightarrow	{  print_unicode(0x21CF); }
\\Leftarrow	{  print_unicode(0x21D0); }
\\Uparrow	{  print_unicode(0x21D1); }
\\Rightarrow	{  print_unicode(0x21D2); }
\\Downarrow	{  print_unicode(0x21D3); }
\\Leftrightarrow	{  print_unicode(0x21D4); }
\\Updownarrow	{  print_unicode(0x21D5); }
\\Nwarrow	{  print_unicode(0x21D6); }
\\Nearrow	{  print_unicode(0x21D7); }
\\Searrow	{  print_unicode(0x21D8); }
\\Swarrow	{  print_unicode(0x21D9); }
\\Lleftarrow	{  print_unicode(0x21DA); }
\\Rrightarrow	{  print_unicode(0x21DB); }
\\leftsquigarrow	{  print_unicode(0x21DC); }
\\rightsquigarrow	{  print_unicode(0x21DD); }
\\nHuparrow	{  print_unicode(0x21DE); }
\\nHdownarrow	{  print_unicode(0x21DF); }
\\leftdasharrow	{  print_unicode(0x21E0); }
\\updasharrow	{  print_unicode(0x21E1); }
\\rightdasharrow	{  print_unicode(0x21E2); }
\\downdasharrow	{  print_unicode(0x21E3); }
\\barleftarrow	{  print_unicode(0x21E4); }
\\rightarrowbar	{  print_unicode(0x21E5); }
\\leftwhitearrow	{  print_unicode(0x21E6); }
\\upwhitearrow	{  print_unicode(0x21E7); }
\\rightwhitearrow	{  print_unicode(0x21E8); }
\\downwhitearrow	{  print_unicode(0x21E9); }
\\whitearrowupfrombar	{  print_unicode(0x21EA); }
\\circleonrightarrow	{  print_unicode(0x21F4); }
\\downuparrows	{  print_unicode(0x21F5); }
\\rightthreearrows	{  print_unicode(0x21F6); }
\\nvleftarrow	{  print_unicode(0x21F7); }
\\nvrightarrow	{  print_unicode(0x21F8); }
\\nvleftrightarrow	{  print_unicode(0x21F9); }
\\nVleftarrow	{  print_unicode(0x21FA); }
\\nVrightarrow	{  print_unicode(0x21FB); }
\\nVleftrightarrow	{  print_unicode(0x21FC); }
\\leftarrowtriangle	{  print_unicode(0x21FD); }
\\rightarrowtriangle	{  print_unicode(0x21FE); }
\\leftrightarrowtriangle	{  print_unicode(0x21FF); }
\\forall	{  print_unicode(0x2200); }
\\complement	{  print_unicode(0x2201); }
\\partial	{  print_unicode(0x2202); }
\\exists	{  print_unicode(0x2203); }
\\nexists	{  print_unicode(0x2204); }
\\varnothing	{  print_unicode(0x2205); }
\\increment	{  print_unicode(0x2206); }
\\nabla	{  print_unicode(0x2207); }
\\in	{  print_unicode(0x2208); }
\\notin	{  print_unicode(0x2209); }
\\smallin	{  print_unicode(0x220A); }
\\ni	{  print_unicode(0x220B); }
\\nni	{  print_unicode(0x220C); }
\\smallni	{  print_unicode(0x220D); }
\\QED	{  print_unicode(0x220E); }
\\prod	{  print_unicode(0x220F); }
\\coprod	{  print_unicode(0x2210); }
\\sum	{  print_unicode(0x2211); }
\\minus	{  print_unicode(0x2212); }
\\mp	{  print_unicode(0x2213); }
\\dotplus	{  print_unicode(0x2214); }
\\divslash	{  print_unicode(0x2215); }
\\smallsetminus	{  print_unicode(0x2216); }
\\ast	{  print_unicode(0x2217); }
\\vysmwhtcircle	{  print_unicode(0x2218); }
\\vysmblkcircle	{  print_unicode(0x2219); }
\\sqrt	{  print_unicode(0x221A); }
\\surd	{  print_unicode(0x221A); }
\\cuberoot	{  print_unicode(0x221B); }
\\fourthroot	{  print_unicode(0x221C); }
\\propto	{  print_unicode(0x221D); }
\\infty	{  print_unicode(0x221E); }
\\rightangle	{  print_unicode(0x221F); }
\\angle	{  print_unicode(0x2220); }
\\measuredangle	{  print_unicode(0x2221); }
\\sphericalangle	{  print_unicode(0x2222); }
\\mid	{  print_unicode(0x2223); }
\\nmid	{  print_unicode(0x2224); }
\\parallel	{  print_unicode(0x2225); }
\\nparallel	{  print_unicode(0x2226); }
\\wedge	{  print_unicode(0x2227); }
\\vee	{  print_unicode(0x2228); }
\\cap	{  print_unicode(0x2229); }
\\cup	{  print_unicode(0x222A); }
\\int	{  print_unicode(0x222B); }
\\iint	{  print_unicode(0x222C); }
\\iiint	{  print_unicode(0x222D); }
\\oint	{  print_unicode(0x222E); }
\\oiint	{  print_unicode(0x222F); }
\\oiiint	{  print_unicode(0x2230); }
\\intclockwise	{  print_unicode(0x2231); }
\\varointclockwise	{  print_unicode(0x2232); }
\\ointctrclockwise	{  print_unicode(0x2233); }
\\therefore	{  print_unicode(0x2234); }
\\because	{  print_unicode(0x2235); }
\\mathratio	{  print_unicode(0x2236); }
\\Colon	{  print_unicode(0x2237); }
\\dotminus	{  print_unicode(0x2238); }
\\dashcolon	{  print_unicode(0x2239); }
\\dotsminusdots	{  print_unicode(0x223A); }
\\kernelcontraction	{  print_unicode(0x223B); }
\\sim	{  print_unicode(0x223C); }
\\backsim	{  print_unicode(0x223D); }
\\invlazys	{  print_unicode(0x223E); }
\\sinewave	{  print_unicode(0x223F); }
\\wr	{  print_unicode(0x2240); }
\\nsim	{  print_unicode(0x2241); }
\\eqsim	{  print_unicode(0x2242); }
\\simeq	{  print_unicode(0x2243); }
\\nsime	{  print_unicode(0x2244); }
\\sime	{  print_unicode(0x2243); }
\\nsimeq	{  print_unicode(0x2244); }
\\cong	{  print_unicode(0x2245); }
\\simneqq	{  print_unicode(0x2246); }
\\ncong	{  print_unicode(0x2247); }
\\approx	{  print_unicode(0x2248); }
\\napprox	{  print_unicode(0x2249); }
\\approxeq	{  print_unicode(0x224A); }
\\approxident	{  print_unicode(0x224B); }
\\backcong	{  print_unicode(0x224C); }
\\asymp	{  print_unicode(0x224D); }
\\Bumpeq	{  print_unicode(0x224E); }
\\bumpeq	{  print_unicode(0x224F); }
\\doteq	{  print_unicode(0x2250); }
\\Doteq	{  print_unicode(0x2251); }
\\fallingdotseq	{  print_unicode(0x2252); }
\\risingdotseq	{  print_unicode(0x2253); }
\\coloneq	{  print_unicode(0x2254); }
\\eqcolon	{  print_unicode(0x2255); }
\\eqcirc	{  print_unicode(0x2256); }
\\circeq	{  print_unicode(0x2257); }
\\arceq	{  print_unicode(0x2258); }
\\wedgeq	{  print_unicode(0x2259); }
\\veeeq	{  print_unicode(0x225A); }
\\stareq	{  print_unicode(0x225B); }
\\triangleq	{  print_unicode(0x225C); }
\\eqdef	{  print_unicode(0x225D); }
\\measeq	{  print_unicode(0x225E); }
\\questeq	{  print_unicode(0x225F); }
\\ne	{  print_unicode(0x2260); }
\\equiv	{  print_unicode(0x2261); }
\\nequiv	{  print_unicode(0x2262); }
\\Equiv	{  print_unicode(0x2263); }
\\leq	{  print_unicode(0x2264); }
\\geq	{  print_unicode(0x2265); }
\\leqq	{  print_unicode(0x2266); }
\\geqq	{  print_unicode(0x2267); }
\\lneqq	{  print_unicode(0x2268); }
\\gneqq	{  print_unicode(0x2269); }
\\ll	{  print_unicode(0x226A); }
\\gg	{  print_unicode(0x226B); }
\\between	{  print_unicode(0x226C); }
\\nasymp	{  print_unicode(0x226D); }
\\nless	{  print_unicode(0x226E); }
\\ngtr	{  print_unicode(0x226F); }
\\nleq	{  print_unicode(0x2270); }
\\ngeq	{  print_unicode(0x2271); }
\\lesssim	{  print_unicode(0x2272); }
\\gtrsim	{  print_unicode(0x2273); }
\\nlesssim	{  print_unicode(0x2274); }
\\ngtrsim	{  print_unicode(0x2275); }
\\lessgtr	{  print_unicode(0x2276); }
\\gtrless	{  print_unicode(0x2277); }
\\nlessgtr	{  print_unicode(0x2278); }
\\ngtrless	{  print_unicode(0x2279); }
\\prec	{  print_unicode(0x227A); }
\\succ	{  print_unicode(0x227B); }
\\preccurlyeq	{  print_unicode(0x227C); }
\\succcurlyeq	{  print_unicode(0x227D); }
\\precsim	{  print_unicode(0x227E); }
\\succsim	{  print_unicode(0x227F); }
\\nprec	{  print_unicode(0x2280); }
\\nsucc	{  print_unicode(0x2281); }
\\subset	{  print_unicode(0x2282); }
\\supset	{  print_unicode(0x2283); }
\\nsubset	{  print_unicode(0x2284); }
\\nsupset	{  print_unicode(0x2285); }
\\subseteq	{  print_unicode(0x2286); }
\\supseteq	{  print_unicode(0x2287); }
\\nsubseteq	{  print_unicode(0x2288); }
\\nsupseteq	{  print_unicode(0x2289); }
\\subsetneq	{  print_unicode(0x228A); }
\\supsetneq	{  print_unicode(0x228B); }
\\cupleftarrow	{  print_unicode(0x228C); }
\\cupdot	{  print_unicode(0x228D); }
\\uplus	{  print_unicode(0x228E); }
\\sqsubset	{  print_unicode(0x228F); }
\\sqsupset	{  print_unicode(0x2290); }
\\sqsubseteq	{  print_unicode(0x2291); }
\\sqsupseteq	{  print_unicode(0x2292); }
\\sqcap	{  print_unicode(0x2293); }
\\sqcup	{  print_unicode(0x2294); }
\\oplus	{  print_unicode(0x2295); }
\\ominus	{  print_unicode(0x2296); }
\\otimes	{  print_unicode(0x2297); }
\\oslash	{  print_unicode(0x2298); }
\\odot	{  print_unicode(0x2299); }
\\circledcirc	{  print_unicode(0x229A); }
\\circledast	{  print_unicode(0x229B); }
\\circledequal	{  print_unicode(0x229C); }
\\circleddash	{  print_unicode(0x229D); }
\\boxplus	{  print_unicode(0x229E); }
\\boxminus	{  print_unicode(0x229F); }
\\boxtimes	{  print_unicode(0x22A0); }
\\boxdot	{  print_unicode(0x22A1); }
\\vdash	{  print_unicode(0x22A2); }
\\dashv	{  print_unicode(0x22A3); }
\\top	{  print_unicode(0x22A4); }
\\bot	{  print_unicode(0x22A5); }
\\assert	{  print_unicode(0x22A6); }
\\models	{  print_unicode(0x22A7); }
\\vDash	{  print_unicode(0x22A8); }
\\Vdash	{  print_unicode(0x22A9); }
\\Vvdash	{  print_unicode(0x22AA); }
\\VDash	{  print_unicode(0x22AB); }
\\nvdash	{  print_unicode(0x22AC); }
\\nvDash	{  print_unicode(0x22AD); }
\\nVdash	{  print_unicode(0x22AE); }
\\nVDash	{  print_unicode(0x22AF); }
\\prurel	{  print_unicode(0x22B0); }
\\scurel	{  print_unicode(0x22B1); }
\\vartriangleleft	{  print_unicode(0x22B2); }
\\vartriangleright	{  print_unicode(0x22B3); }
\\trianglelefteq	{  print_unicode(0x22B4); }
\\trianglerighteq	{  print_unicode(0x22B5); }
\\origof	{  print_unicode(0x22B6); }
\\imageof	{  print_unicode(0x22B7); }
\\multimap	{  print_unicode(0x22B8); }
\\hermitmatrix	{  print_unicode(0x22B9); }
\\intercal	{  print_unicode(0x22BA); }
\\veebar	{  print_unicode(0x22BB); }
\\barwedge	{  print_unicode(0x22BC); }
\\barvee	{  print_unicode(0x22BD); }
\\measuredrightangle	{  print_unicode(0x22BE); }
\\varlrtriangle	{  print_unicode(0x22BF); }
\\bigwedge	{  print_unicode(0x22C0); }
\\bigvee	{  print_unicode(0x22C1); }
\\bigcap	{  print_unicode(0x22C2); }
\\bigcup	{  print_unicode(0x22C3); }
\\smwhtdiamond	{  print_unicode(0x22C4); }
\\cdot	{  print_unicode(0x22C5); }
\\star	{  print_unicode(0x22C6); }
\\divideontimes	{  print_unicode(0x22C7); }
\\bowtie	{  print_unicode(0x22C8); }
\\ltimes	{  print_unicode(0x22C9); }
\\rtimes	{  print_unicode(0x22CA); }
\\leftthreetimes	{  print_unicode(0x22CB); }
\\rightthreetimes	{  print_unicode(0x22CC); }
\\backsimeq	{  print_unicode(0x22CD); }
\\curlyvee	{  print_unicode(0x22CE); }
\\curlywedge	{  print_unicode(0x22CF); }
\\Subset	{  print_unicode(0x22D0); }
\\Supset	{  print_unicode(0x22D1); }
\\Cap	{  print_unicode(0x22D2); }
\\Cup	{  print_unicode(0x22D3); }
\\pitchfork	{  print_unicode(0x22D4); }
\\equalparallel	{  print_unicode(0x22D5); }
\\lessdot	{  print_unicode(0x22D6); }
\\gtrdot	{  print_unicode(0x22D7); }
\\lll	{  print_unicode(0x22D8); }
\\ggg	{  print_unicode(0x22D9); }
\\lesseqgtr	{  print_unicode(0x22DA); }
\\gtreqless	{  print_unicode(0x22DB); }
\\eqless	{  print_unicode(0x22DC); }
\\eqgtr	{  print_unicode(0x22DD); }
\\curlyeqprec	{  print_unicode(0x22DE); }
\\curlyeqsucc	{  print_unicode(0x22DF); }
\\npreccurlyeq	{  print_unicode(0x22E0); }
\\nsucccurlyeq	{  print_unicode(0x22E1); }
\\nsqsubseteq	{  print_unicode(0x22E2); }
\\nsqsupseteq	{  print_unicode(0x22E3); }
\\sqsubsetneq	{  print_unicode(0x22E4); }
\\sqsupsetneq	{  print_unicode(0x22E5); }
\\lnsim	{  print_unicode(0x22E6); }
\\gnsim	{  print_unicode(0x22E7); }
\\precnsim	{  print_unicode(0x22E8); }
\\succnsim	{  print_unicode(0x22E9); }
\\nvartriangleleft	{  print_unicode(0x22EA); }
\\nvartriangleright	{  print_unicode(0x22EB); }
\\ntrianglelefteq	{  print_unicode(0x22EC); }
\\ntrianglerighteq	{  print_unicode(0x22ED); }
\\vdots	{  print_unicode(0x22EE); }
\\unicodecdots	{  print_unicode(0x22EF); }
\\adots	{  print_unicode(0x22F0); }
\\ddots	{  print_unicode(0x22F1); }
\\disin	{  print_unicode(0x22F2); }
\\varisins	{  print_unicode(0x22F3); }
\\isins	{  print_unicode(0x22F4); }
\\isindot	{  print_unicode(0x22F5); }
\\varisinobar	{  print_unicode(0x22F6); }
\\isinobar	{  print_unicode(0x22F7); }
\\isinvb	{  print_unicode(0x22F8); }
\\isinE	{  print_unicode(0x22F9); }
\\nisd	{  print_unicode(0x22FA); }
\\varnis	{  print_unicode(0x22FB); }
\\nis	{  print_unicode(0x22FC); }
\\varniobar	{  print_unicode(0x22FD); }
\\niobar	{  print_unicode(0x22FE); }
\\bagmember	{  print_unicode(0x22FF); }
\\diameter	{  print_unicode(0x2300); }
\\house	{  print_unicode(0x2302); }
\\varbarwedge	{  print_unicode(0x2305); }
\\vardoublebarwedge	{  print_unicode(0x2306); }
\\lceil	{  print_unicode(0x2308); }
\\rceil	{  print_unicode(0x2309); }
\\lfloor	{  print_unicode(0x230A); }
\\rfloor	{  print_unicode(0x230B); }
\\invnot	{  print_unicode(0x2310); }
\\sqlozenge	{  print_unicode(0x2311); }
\\profline	{  print_unicode(0x2312); }
\\profsurf	{  print_unicode(0x2313); }
\\viewdata	{  print_unicode(0x2317); }
\\turnednot	{  print_unicode(0x2319); }
\\ulcorner	{  print_unicode(0x231C); }
\\urcorner	{  print_unicode(0x231D); }
\\llcorner	{  print_unicode(0x231E); }
\\lrcorner	{  print_unicode(0x231F); }
\\inttop	{  print_unicode(0x2320); }
\\intbottom	{  print_unicode(0x2321); }
\\frown	{  print_unicode(0x2322); }
\\smile	{  print_unicode(0x2323); }
\\varhexagonlrbonds	{  print_unicode(0x232C); }
\\conictaper	{  print_unicode(0x2332); }
\\topbot	{  print_unicode(0x2336); }
\\obar	{  print_unicode(0x233D); }
\\APLnotslash	{  print_unicode(0x233F); }
\\APLnotbackslash	{  print_unicode(0x2340); }
\\APLboxupcaret	{  print_unicode(0x2353); }
\\APLboxquestion	{  print_unicode(0x2370); }
\\rangledownzigzagarrow	{  print_unicode(0x237C); }
\\hexagon	{  print_unicode(0x2394); }
\\lparenuend	{  print_unicode(0x239B); }
\\lparenextender	{  print_unicode(0x239C); }
\\lparenlend	{  print_unicode(0x239D); }
\\rparenuend	{  print_unicode(0x239E); }
\\rparenextender	{  print_unicode(0x239F); }
\\rparenlend	{  print_unicode(0x23A0); }
\\lbrackuend	{  print_unicode(0x23A1); }
\\lbrackextender	{  print_unicode(0x23A2); }
\\lbracklend	{  print_unicode(0x23A3); }
\\rbrackuend	{  print_unicode(0x23A4); }
\\rbrackextender	{  print_unicode(0x23A5); }
\\rbracklend	{  print_unicode(0x23A6); }
\\lbraceuend	{  print_unicode(0x23A7); }
\\lbracemid	{  print_unicode(0x23A8); }
\\lbracelend	{  print_unicode(0x23A9); }
\\vbraceextender	{  print_unicode(0x23AA); }
\\rbraceuend	{  print_unicode(0x23AB); }
\\rbracemid	{  print_unicode(0x23AC); }
\\rbracelend	{  print_unicode(0x23AD); }
\\intextender	{  print_unicode(0x23AE); }
\\harrowextender	{  print_unicode(0x23AF); }
\\lmoustache	{  print_unicode(0x23B0); }
\\rmoustache	{  print_unicode(0x23B1); }
\\sumtop	{  print_unicode(0x23B2); }
\\sumbottom	{  print_unicode(0x23B3); }
\\overbracket	{  print_unicode(0x23B4); }
\\underbracket	{  print_unicode(0x23B5); }
\\bbrktbrk	{  print_unicode(0x23B6); }
\\sqrtbottom	{  print_unicode(0x23B7); }
\\lvboxline	{  print_unicode(0x23B8); }
\\rvboxline	{  print_unicode(0x23B9); }
\\varcarriagereturn	{  print_unicode(0x23CE); }
\\overparen	{  print_unicode(0x23DC); }
\\underparen	{  print_unicode(0x23DD); }
\\overbrace	{  print_unicode(0x23DE); }
\\underbrace	{  print_unicode(0x23DF); }
\\obrbrak	{  print_unicode(0x23E0); }
\\ubrbrak	{  print_unicode(0x23E1); }
\\trapezium	{  print_unicode(0x23E2); }
\\benzenr	{  print_unicode(0x23E3); }
\\strns	{  print_unicode(0x23E4); }
\\fltns	{  print_unicode(0x23E5); }
\\accurrent	{  print_unicode(0x23E6); }
\\elinters	{  print_unicode(0x23E7); }
\\blanksymbol	{  print_unicode(0x2422); }
\\mathvisiblespace	{  print_unicode(0x2423); }
\\bdtriplevdash	{  print_unicode(0x2506); }
\\blockuphalf	{  print_unicode(0x2580); }
\\blocklowhalf	{  print_unicode(0x2584); }
\\blockfull	{  print_unicode(0x2588); }
\\blocklefthalf	{  print_unicode(0x258C); }
\\blockrighthalf	{  print_unicode(0x2590); }
\\blockqtrshaded	{  print_unicode(0x2591); }
\\blockhalfshaded	{  print_unicode(0x2592); }
\\blockthreeqtrshaded	{  print_unicode(0x2593); }
\\mdlgblksquare	{  print_unicode(0x25A0); }
\\mdlgwhtsquare	{  print_unicode(0x25A1); }
\\squoval	{  print_unicode(0x25A2); }
\\blackinwhitesquare	{  print_unicode(0x25A3); }
\\squarehfill	{  print_unicode(0x25A4); }
\\squarevfill	{  print_unicode(0x25A5); }
\\squarehvfill	{  print_unicode(0x25A6); }
\\squarenwsefill	{  print_unicode(0x25A7); }
\\squareneswfill	{  print_unicode(0x25A8); }
\\squarecrossfill	{  print_unicode(0x25A9); }
\\smblksquare	{  print_unicode(0x25AA); }
\\smwhtsquare	{  print_unicode(0x25AB); }
\\hrectangleblack	{  print_unicode(0x25AC); }
\\hrectangle	{  print_unicode(0x25AD); }
\\vrectangleblack	{  print_unicode(0x25AE); }
\\vrectangle	{  print_unicode(0x25AF); }
\\parallelogramblack	{  print_unicode(0x25B0); }
\\parallelogram	{  print_unicode(0x25B1); }
\\bigblacktriangleup	{  print_unicode(0x25B2); }
\\bigtriangleup	{  print_unicode(0x25B3); }
\\blacktriangle	{  print_unicode(0x25B4); }
\\vartriangle	{  print_unicode(0x25B5); }
\\blacktriangleright	{  print_unicode(0x25B6); }
\\triangleright	{  print_unicode(0x25B7); }
\\smallblacktriangleright	{  print_unicode(0x25B8); }
\\smalltriangleright	{  print_unicode(0x25B9); }
\\blackpointerright	{  print_unicode(0x25BA); }
\\whitepointerright	{  print_unicode(0x25BB); }
\\bigblacktriangledown	{  print_unicode(0x25BC); }
\\bigtriangledown	{  print_unicode(0x25BD); }
\\blacktriangledown	{  print_unicode(0x25BE); }
\\triangledown	{  print_unicode(0x25BF); }
\\blacktriangleleft	{  print_unicode(0x25C0); }
\\triangleleft	{  print_unicode(0x25C1); }
\\smallblacktriangleleft	{  print_unicode(0x25C2); }
\\smalltriangleleft	{  print_unicode(0x25C3); }
\\blackpointerleft	{  print_unicode(0x25C4); }
\\whitepointerleft	{  print_unicode(0x25C5); }
\\mdlgblkdiamond	{  print_unicode(0x25C6); }
\\mdlgwhtdiamond	{  print_unicode(0x25C7); }
\\blackinwhitediamond	{  print_unicode(0x25C8); }
\\fisheye	{  print_unicode(0x25C9); }
\\mdlgwhtlozenge	{  print_unicode(0x25CA); }
\\mdlgwhtcircle	{  print_unicode(0x25CB); }
\\dottedcircle	{  print_unicode(0x25CC); }
\\circlevertfill	{  print_unicode(0x25CD); }
\\bullseye	{  print_unicode(0x25CE); }
\\mdlgblkcircle	{  print_unicode(0x25CF); }
\\circlelefthalfblack	{  print_unicode(0x25D0); }
\\circlerighthalfblack	{  print_unicode(0x25D1); }
\\circlebottomhalfblack	{  print_unicode(0x25D2); }
\\circletophalfblack	{  print_unicode(0x25D3); }
\\circleurquadblack	{  print_unicode(0x25D4); }
\\blackcircleulquadwhite	{  print_unicode(0x25D5); }
\\blacklefthalfcircle	{  print_unicode(0x25D6); }
\\blackrighthalfcircle	{  print_unicode(0x25D7); }
\\inversebullet	{  print_unicode(0x25D8); }
\\inversewhitecircle	{  print_unicode(0x25D9); }
\\invwhiteupperhalfcircle	{  print_unicode(0x25DA); }
\\invwhitelowerhalfcircle	{  print_unicode(0x25DB); }
\\ularc	{  print_unicode(0x25DC); }
\\urarc	{  print_unicode(0x25DD); }
\\lrarc	{  print_unicode(0x25DE); }
\\llarc	{  print_unicode(0x25DF); }
\\topsemicircle	{  print_unicode(0x25E0); }
\\botsemicircle	{  print_unicode(0x25E1); }
\\lrblacktriangle	{  print_unicode(0x25E2); }
\\llblacktriangle	{  print_unicode(0x25E3); }
\\ulblacktriangle	{  print_unicode(0x25E4); }
\\urblacktriangle	{  print_unicode(0x25E5); }
\\smwhtcircle	{  print_unicode(0x25E6); }
\\squareleftblack	{  print_unicode(0x25E7); }
\\squarerightblack	{  print_unicode(0x25E8); }
\\squareulblack	{  print_unicode(0x25E9); }
\\squarelrblack	{  print_unicode(0x25EA); }
\\boxbar	{  print_unicode(0x25EB); }
\\trianglecdot	{  print_unicode(0x25EC); }
\\triangleleftblack	{  print_unicode(0x25ED); }
\\trianglerightblack	{  print_unicode(0x25EE); }
\\lgwhtcircle	{  print_unicode(0x25EF); }
\\squareulquad	{  print_unicode(0x25F0); }
\\squarellquad	{  print_unicode(0x25F1); }
\\squarelrquad	{  print_unicode(0x25F2); }
\\squareurquad	{  print_unicode(0x25F3); }
\\circleulquad	{  print_unicode(0x25F4); }
\\circlellquad	{  print_unicode(0x25F5); }
\\circlelrquad	{  print_unicode(0x25F6); }
\\circleurquad	{  print_unicode(0x25F7); }
\\ultriangle	{  print_unicode(0x25F8); }
\\urtriangle	{  print_unicode(0x25F9); }
\\lltriangle	{  print_unicode(0x25FA); }
\\mdwhtsquare	{  print_unicode(0x25FB); }
\\mdblksquare	{  print_unicode(0x25FC); }
\\mdsmwhtsquare	{  print_unicode(0x25FD); }
\\mdsmblksquare	{  print_unicode(0x25FE); }
\\lrtriangle	{  print_unicode(0x25FF); }
\\bigstar	{  print_unicode(0x2605); }
\\bigwhitestar	{  print_unicode(0x2606); }
\\astrosun	{  print_unicode(0x2609); }
\\danger	{  print_unicode(0x2621); }
\\blacksmiley	{  print_unicode(0x263B); }
\\sun	{  print_unicode(0x263C); }
\\rightmoon	{  print_unicode(0x263D); }
\\leftmoon	{  print_unicode(0x263E); }
\\female	{  print_unicode(0x2640); }
\\male	{  print_unicode(0x2642); }
\\spadesuit	{  print_unicode(0x2660); }
\\heartsuit	{  print_unicode(0x2661); }
\\diamondsuit	{  print_unicode(0x2662); }
\\clubsuit	{  print_unicode(0x2663); }
\\varspadesuit	{  print_unicode(0x2664); }
\\varheartsuit	{  print_unicode(0x2665); }
\\vardiamondsuit	{  print_unicode(0x2666); }
\\varclubsuit	{  print_unicode(0x2667); }
\\quarternote	{  print_unicode(0x2669); }
\\eighthnote	{  print_unicode(0x266A); }
\\twonotes	{  print_unicode(0x266B); }
\\flat	{  print_unicode(0x266D); }
\\natural	{  print_unicode(0x266E); }
\\sharp	{  print_unicode(0x266F); }
\\acidfree	{  print_unicode(0x267E); }
\\dicei	{  print_unicode(0x2680); }
\\diceii	{  print_unicode(0x2681); }
\\diceiii	{  print_unicode(0x2682); }
\\diceiv	{  print_unicode(0x2683); }
\\dicev	{  print_unicode(0x2684); }
\\dicevi	{  print_unicode(0x2685); }
\\circledrightdot	{  print_unicode(0x2686); }
\\circledtwodots	{  print_unicode(0x2687); }
\\blackcircledrightdot	{  print_unicode(0x2688); }
\\blackcircledtwodots	{  print_unicode(0x2689); }
\\Hermaphrodite	{  print_unicode(0x26A5); }
\\mdwhtcircle	{  print_unicode(0x26AA); }
\\mdblkcircle	{  print_unicode(0x26AB); }
\\mdsmwhtcircle	{  print_unicode(0x26AC); }
\\neuter	{  print_unicode(0x26B2); }
\\checkmark	{  print_unicode(0x2713); }
\\maltese	{  print_unicode(0x2720); }
\\circledstar	{  print_unicode(0x272A); }
\\varstar	{  print_unicode(0x2736); }
\\dingasterisk	{  print_unicode(0x273D); }
\\lbrbrak	{  print_unicode(0x2772); }
\\rbrbrak	{  print_unicode(0x2773); }
\\draftingarrow	{  print_unicode(0x279B); }
\\threedangle	{  print_unicode(0x27C0); }
\\whiteinwhitetriangle	{  print_unicode(0x27C1); }
\\perp	{  print_unicode(0x27C2); }
\\subsetcirc	{  print_unicode(0x27C3); }
\\supsetcirc	{  print_unicode(0x27C4); }
\\lbag	{  print_unicode(0x27C5); }
\\rbag	{  print_unicode(0x27C6); }
\\veedot	{  print_unicode(0x27C7); }
\\bsolhsub	{  print_unicode(0x27C8); }
\\suphsol	{  print_unicode(0x27C9); }
\\longdivision	{  print_unicode(0x27CC); }
\\diamondcdot	{  print_unicode(0x27D0); }
\\wedgedot	{  print_unicode(0x27D1); }
\\upin	{  print_unicode(0x27D2); }
\\pullback	{  print_unicode(0x27D3); }
\\pushout	{  print_unicode(0x27D4); }
\\leftouterjoin	{  print_unicode(0x27D5); }
\\rightouterjoin	{  print_unicode(0x27D6); }
\\fullouterjoin	{  print_unicode(0x27D7); }
\\bigbot	{  print_unicode(0x27D8); }
\\bigtop	{  print_unicode(0x27D9); }
\\DashVDash	{  print_unicode(0x27DA); }
\\dashVdash	{  print_unicode(0x27DB); }
\\multimapinv	{  print_unicode(0x27DC); }
\\vlongdash	{  print_unicode(0x27DD); }
\\longdashv	{  print_unicode(0x27DE); }
\\cirbot	{  print_unicode(0x27DF); }
\\lozengeminus	{  print_unicode(0x27E0); }
\\concavediamond	{  print_unicode(0x27E1); }
\\concavediamondtickleft	{  print_unicode(0x27E2); }
\\concavediamondtickright	{  print_unicode(0x27E3); }
\\whitesquaretickleft	{  print_unicode(0x27E4); }
\\whitesquaretickright	{  print_unicode(0x27E5); }
\\lBrack	{  print_unicode(0x27E6); }
\\rBrack	{  print_unicode(0x27E7); }
\\langle	{  print_unicode(0x27E8); }
\\rangle	{  print_unicode(0x27E9); }
\\lAngle	{  print_unicode(0x27EA); }
\\rAngle	{  print_unicode(0x27EB); }
\\Lbrbrak	{  print_unicode(0x27EC); }
\\Rbrbrak	{  print_unicode(0x27ED); }
\\lgroup	{  print_unicode(0x27EE); }
\\rgroup	{  print_unicode(0x27EF); }
\\UUparrow	{  print_unicode(0x27F0); }
\\DDownarrow	{  print_unicode(0x27F1); }
\\acwgapcirclearrow	{  print_unicode(0x27F2); }
\\cwgapcirclearrow	{  print_unicode(0x27F3); }
\\rightarrowonoplus	{  print_unicode(0x27F4); }
\\longleftarrow	{  print_unicode(0x27F5); }
\\longrightarrow	{  print_unicode(0x27F6); }
\\longleftrightarrow	{  print_unicode(0x27F7); }
\\Longleftarrow	{  print_unicode(0x27F8); }
\\Longrightarrow	{  print_unicode(0x27F9); }
\\Longleftrightarrow	{  print_unicode(0x27FA); }
\\longmapsfrom	{  print_unicode(0x27FB); }
\\longmapsto	{  print_unicode(0x27FC); }
\\Longmapsfrom	{  print_unicode(0x27FD); }
\\Longmapsto	{  print_unicode(0x27FE); }
\\longrightsquigarrow	{  print_unicode(0x27FF); }
\\nvtwoheadrightarrow	{  print_unicode(0x2900); }
\\nVtwoheadrightarrow	{  print_unicode(0x2901); }
\\nvLeftarrow	{  print_unicode(0x2902); }
\\nvRightarrow	{  print_unicode(0x2903); }
\\nvLeftrightarrow	{  print_unicode(0x2904); }
\\twoheadmapsto	{  print_unicode(0x2905); }
\\Mapsfrom	{  print_unicode(0x2906); }
\\Mapsto	{  print_unicode(0x2907); }
\\downarrowbarred	{  print_unicode(0x2908); }
\\uparrowbarred	{  print_unicode(0x2909); }
\\Uuparrow	{  print_unicode(0x290A); }
\\Ddownarrow	{  print_unicode(0x290B); }
\\leftbkarrow	{  print_unicode(0x290C); }
\\rightbkarrow	{  print_unicode(0x290D); }
\\leftdbkarrow	{  print_unicode(0x290E); }
\\dbkarrow	{  print_unicode(0x290F); }
\\drbkarrow	{  print_unicode(0x2910); }
\\rightdotarrow	{  print_unicode(0x2911); }
\\baruparrow	{  print_unicode(0x2912); }
\\downarrowbar	{  print_unicode(0x2913); }
\\nvrightarrowtail	{  print_unicode(0x2914); }
\\nVrightarrowtail	{  print_unicode(0x2915); }
\\twoheadrightarrowtail	{  print_unicode(0x2916); }
\\nvtwoheadrightarrowtail	{  print_unicode(0x2917); }
\\nVtwoheadrightarrowtail	{  print_unicode(0x2918); }
\\lefttail	{  print_unicode(0x2919); }
\\righttail	{  print_unicode(0x291A); }
\\leftdbltail	{  print_unicode(0x291B); }
\\rightdbltail	{  print_unicode(0x291C); }
\\diamondleftarrow	{  print_unicode(0x291D); }
\\rightarrowdiamond	{  print_unicode(0x291E); }
\\diamondleftarrowbar	{  print_unicode(0x291F); }
\\barrightarrowdiamond	{  print_unicode(0x2920); }
\\nwsearrow	{  print_unicode(0x2921); }
\\neswarrow	{  print_unicode(0x2922); }
\\hknwarrow	{  print_unicode(0x2923); }
\\hknearrow	{  print_unicode(0x2924); }
\\hksearrow	{  print_unicode(0x2925); }
\\hkswarrow	{  print_unicode(0x2926); }
\\tona	{  print_unicode(0x2927); }
\\toea	{  print_unicode(0x2928); }
\\tosa	{  print_unicode(0x2929); }
\\towa	{  print_unicode(0x292A); }
\\rdiagovfdiag	{  print_unicode(0x292B); }
\\fdiagovrdiag	{  print_unicode(0x292C); }
\\seovnearrow	{  print_unicode(0x292D); }
\\neovsearrow	{  print_unicode(0x292E); }
\\fdiagovnearrow	{  print_unicode(0x292F); }
\\rdiagovsearrow	{  print_unicode(0x2930); }
\\neovnwarrow	{  print_unicode(0x2931); }
\\nwovnearrow	{  print_unicode(0x2932); }
\\rightcurvedarrow	{  print_unicode(0x2933); }
\\uprightcurvearrow	{  print_unicode(0x2934); }
\\downrightcurvedarrow	{  print_unicode(0x2935); }
\\leftdowncurvedarrow	{  print_unicode(0x2936); }
\\rightdowncurvedarrow	{  print_unicode(0x2937); }
\\cwrightarcarrow	{  print_unicode(0x2938); }
\\acwleftarcarrow	{  print_unicode(0x2939); }
\\acwoverarcarrow	{  print_unicode(0x293A); }
\\acwunderarcarrow	{  print_unicode(0x293B); }
\\curvearrowrightminus	{  print_unicode(0x293C); }
\\curvearrowleftplus	{  print_unicode(0x293D); }
\\cwundercurvearrow	{  print_unicode(0x293E); }
\\ccwundercurvearrow	{  print_unicode(0x293F); }
\\acwcirclearrow	{  print_unicode(0x2940); }
\\cwcirclearrow	{  print_unicode(0x2941); }
\\rightarrowshortleftarrow	{  print_unicode(0x2942); }
\\leftarrowshortrightarrow	{  print_unicode(0x2943); }
\\shortrightarrowleftarrow	{  print_unicode(0x2944); }
\\rightarrowplus	{  print_unicode(0x2945); }
\\leftarrowplus	{  print_unicode(0x2946); }
\\rightarrowx	{  print_unicode(0x2947); }
\\leftrightarrowcircle	{  print_unicode(0x2948); }
\\twoheaduparrowcircle	{  print_unicode(0x2949); }
\\leftrightharpoonupdown	{  print_unicode(0x294A); }
\\leftrightharpoondownup	{  print_unicode(0x294B); }
\\updownharpoonrightleft	{  print_unicode(0x294C); }
\\updownharpoonleftright	{  print_unicode(0x294D); }
\\leftrightharpoonupup	{  print_unicode(0x294E); }
\\updownharpoonrightright	{  print_unicode(0x294F); }
\\leftrightharpoondowndown	{  print_unicode(0x2950); }
\\updownharpoonleftleft	{  print_unicode(0x2951); }
\\barleftharpoonup	{  print_unicode(0x2952); }
\\rightharpoonupbar	{  print_unicode(0x2953); }
\\barupharpoonright	{  print_unicode(0x2954); }
\\downharpoonrightbar	{  print_unicode(0x2955); }
\\barleftharpoondown	{  print_unicode(0x2956); }
\\rightharpoondownbar	{  print_unicode(0x2957); }
\\barupharpoonleft	{  print_unicode(0x2958); }
\\downharpoonleftbar	{  print_unicode(0x2959); }
\\leftharpoonupbar	{  print_unicode(0x295A); }
\\barrightharpoonup	{  print_unicode(0x295B); }
\\upharpoonrightbar	{  print_unicode(0x295C); }
\\bardownharpoonright	{  print_unicode(0x295D); }
\\leftharpoondownbar	{  print_unicode(0x295E); }
\\barrightharpoondown	{  print_unicode(0x295F); }
\\upharpoonleftbar	{  print_unicode(0x2960); }
\\bardownharpoonleft	{  print_unicode(0x2961); }
\\leftharpoonsupdown	{  print_unicode(0x2962); }
\\upharpoonsleftright	{  print_unicode(0x2963); }
\\rightharpoonsupdown	{  print_unicode(0x2964); }
\\downharpoonsleftright	{  print_unicode(0x2965); }
\\leftrightharpoonsup	{  print_unicode(0x2966); }
\\leftrightharpoonsdown	{  print_unicode(0x2967); }
\\rightleftharpoonsup	{  print_unicode(0x2968); }
\\rightleftharpoonsdown	{  print_unicode(0x2969); }
\\leftharpoonupdash	{  print_unicode(0x296A); }
\\dashleftharpoondown	{  print_unicode(0x296B); }
\\rightharpoonupdash	{  print_unicode(0x296C); }
\\dashrightharpoondown	{  print_unicode(0x296D); }
\\updownharpoonsleftright	{  print_unicode(0x296E); }
\\downupharpoonsleftright	{  print_unicode(0x296F); }
\\rightimply	{  print_unicode(0x2970); }
\\equalrightarrow	{  print_unicode(0x2971); }
\\similarrightarrow	{  print_unicode(0x2972); }
\\leftarrowsimilar	{  print_unicode(0x2973); }
\\rightarrowsimilar	{  print_unicode(0x2974); }
\\rightarrowapprox	{  print_unicode(0x2975); }
\\ltlarr	{  print_unicode(0x2976); }
\\leftarrowless	{  print_unicode(0x2977); }
\\gtrarr	{  print_unicode(0x2978); }
\\subrarr	{  print_unicode(0x2979); }
\\leftarrowsubset	{  print_unicode(0x297A); }
\\suplarr	{  print_unicode(0x297B); }
\\leftfishtail	{  print_unicode(0x297C); }
\\rightfishtail	{  print_unicode(0x297D); }
\\upfishtail	{  print_unicode(0x297E); }
\\downfishtail	{  print_unicode(0x297F); }
\\Vvert	{  print_unicode(0x2980); }
\\mdsmblkcircle	{  print_unicode(0x2981); }
\\typecolon	{  print_unicode(0x2982); }
\\lBrace	{  print_unicode(0x2983); }
\\rBrace	{  print_unicode(0x2984); }
\\lParen	{  print_unicode(0x2985); }
\\rParen	{  print_unicode(0x2986); }
\\llparenthesis	{  print_unicode(0x2987); }
\\rrparenthesis	{  print_unicode(0x2988); }
\\llangle	{  print_unicode(0x2989); }
\\rrangle	{  print_unicode(0x298A); }
\\lbrackubar	{  print_unicode(0x298B); }
\\rbrackubar	{  print_unicode(0x298C); }
\\lbrackultick	{  print_unicode(0x298D); }
\\rbracklrtick	{  print_unicode(0x298E); }
\\lbracklltick	{  print_unicode(0x298F); }
\\rbrackurtick	{  print_unicode(0x2990); }
\\langledot	{  print_unicode(0x2991); }
\\rangledot	{  print_unicode(0x2992); }
\\lparenless	{  print_unicode(0x2993); }
\\rparengtr	{  print_unicode(0x2994); }
\\Lparengtr	{  print_unicode(0x2995); }
\\Rparenless	{  print_unicode(0x2996); }
\\lblkbrbrak	{  print_unicode(0x2997); }
\\rblkbrbrak	{  print_unicode(0x2998); }
\\fourvdots	{  print_unicode(0x2999); }
\\vzigzag	{  print_unicode(0x299A); }
\\measuredangleleft	{  print_unicode(0x299B); }
\\rightanglesqr	{  print_unicode(0x299C); }
\\rightanglemdot	{  print_unicode(0x299D); }
\\angles	{  print_unicode(0x299E); }
\\angdnr	{  print_unicode(0x299F); }
\\gtlpar	{  print_unicode(0x29A0); }
\\sphericalangleup	{  print_unicode(0x29A1); }
\\turnangle	{  print_unicode(0x29A2); }
\\revangle	{  print_unicode(0x29A3); }
\\angleubar	{  print_unicode(0x29A4); }
\\revangleubar	{  print_unicode(0x29A5); }
\\wideangledown	{  print_unicode(0x29A6); }
\\wideangleup	{  print_unicode(0x29A7); }
\\measanglerutone	{  print_unicode(0x29A8); }
\\measanglelutonw	{  print_unicode(0x29A9); }
\\measanglerdtose	{  print_unicode(0x29AA); }
\\measangleldtosw	{  print_unicode(0x29AB); }
\\measangleurtone	{  print_unicode(0x29AC); }
\\measangleultonw	{  print_unicode(0x29AD); }
\\measangledrtose	{  print_unicode(0x29AE); }
\\measangledltosw	{  print_unicode(0x29AF); }
\\revemptyset	{  print_unicode(0x29B0); }
\\emptysetobar	{  print_unicode(0x29B1); }
\\emptysetocirc	{  print_unicode(0x29B2); }
\\emptysetoarr	{  print_unicode(0x29B3); }
\\emptysetoarrl	{  print_unicode(0x29B4); }
\\circlehbar	{  print_unicode(0x29B5); }
\\circledvert	{  print_unicode(0x29B6); }
\\circledparallel	{  print_unicode(0x29B7); }
\\obslash	{  print_unicode(0x29B8); }
\\operp	{  print_unicode(0x29B9); }
\\obot	{  print_unicode(0x29BA); }
\\olcross	{  print_unicode(0x29BB); }
\\odotslashdot	{  print_unicode(0x29BC); }
\\uparrowoncircle	{  print_unicode(0x29BD); }
\\circledwhitebullet	{  print_unicode(0x29BE); }
\\circledbullet	{  print_unicode(0x29BF); }
\\olessthan	{  print_unicode(0x29C0); }
\\ogreaterthan	{  print_unicode(0x29C1); }
\\cirscir	{  print_unicode(0x29C2); }
\\cirE	{  print_unicode(0x29C3); }
\\boxdiag	{  print_unicode(0x29C4); }
\\boxbslash	{  print_unicode(0x29C5); }
\\boxast	{  print_unicode(0x29C6); }
\\boxcircle	{  print_unicode(0x29C7); }
\\boxbox	{  print_unicode(0x29C8); }
\\boxonbox	{  print_unicode(0x29C9); }
\\triangleodot	{  print_unicode(0x29CA); }
\\triangleubar	{  print_unicode(0x29CB); }
\\triangles	{  print_unicode(0x29CC); }
\\triangleserifs	{  print_unicode(0x29CD); }
\\rtriltri	{  print_unicode(0x29CE); }
\\ltrivb	{  print_unicode(0x29CF); }
\\vbrtri	{  print_unicode(0x29D0); }
\\lfbowtie	{  print_unicode(0x29D1); }
\\rfbowtie	{  print_unicode(0x29D2); }
\\fbowtie	{  print_unicode(0x29D3); }
\\lftimes	{  print_unicode(0x29D4); }
\\rftimes	{  print_unicode(0x29D5); }
\\hourglass	{  print_unicode(0x29D6); }
\\blackhourglass	{  print_unicode(0x29D7); }
\\lvzigzag	{  print_unicode(0x29D8); }
\\rvzigzag	{  print_unicode(0x29D9); }
\\Lvzigzag	{  print_unicode(0x29DA); }
\\Rvzigzag	{  print_unicode(0x29DB); }
\\iinfin	{  print_unicode(0x29DC); }
\\tieinfty	{  print_unicode(0x29DD); }
\\nvinfty	{  print_unicode(0x29DE); }
\\dualmap	{  print_unicode(0x29DF); }
\\laplac	{  print_unicode(0x29E0); }
\\lrtriangleeq	{  print_unicode(0x29E1); }
\\shuffle	{  print_unicode(0x29E2); }
\\eparsl	{  print_unicode(0x29E3); }
\\smeparsl	{  print_unicode(0x29E4); }
\\eqvparsl	{  print_unicode(0x29E5); }
\\gleichstark	{  print_unicode(0x29E6); }
\\thermod	{  print_unicode(0x29E7); }
\\downtriangleleftblack	{  print_unicode(0x29E8); }
\\downtrianglerightblack	{  print_unicode(0x29E9); }
\\blackdiamonddownarrow	{  print_unicode(0x29EA); }
\\mdlgblklozenge	{  print_unicode(0x29EB); }
\\circledownarrow	{  print_unicode(0x29EC); }
\\blackcircledownarrow	{  print_unicode(0x29ED); }
\\errbarsquare	{  print_unicode(0x29EE); }
\\errbarblacksquare	{  print_unicode(0x29EF); }
\\errbardiamond	{  print_unicode(0x29F0); }
\\errbarblackdiamond	{  print_unicode(0x29F1); }
\\errbarcircle	{  print_unicode(0x29F2); }
\\errbarblackcircle	{  print_unicode(0x29F3); }
\\ruledelayed	{  print_unicode(0x29F4); }
\\setminus	{  print_unicode(0x29F5); }
\\dsol	{  print_unicode(0x29F6); }
\\rsolbar	{  print_unicode(0x29F7); }
\\xsol	{  print_unicode(0x29F8); }
\\xbsol	{  print_unicode(0x29F9); }
\\doubleplus	{  print_unicode(0x29FA); }
\\tripleplus	{  print_unicode(0x29FB); }
\\lcurvyangle	{  print_unicode(0x29FC); }
\\rcurvyangle	{  print_unicode(0x29FD); }
\\tplus	{  print_unicode(0x29FE); }
\\tminus	{  print_unicode(0x29FF); }
\\bigodot	{  print_unicode(0x2A00); }
\\bigoplus	{  print_unicode(0x2A01); }
\\bigotimes	{  print_unicode(0x2A02); }
\\bigcupdot	{  print_unicode(0x2A03); }
\\biguplus	{  print_unicode(0x2A04); }
\\bigsqcap	{  print_unicode(0x2A05); }
\\bigsqcup	{  print_unicode(0x2A06); }
\\conjquant	{  print_unicode(0x2A07); }
\\disjquant	{  print_unicode(0x2A08); }
\\bigtimes	{  print_unicode(0x2A09); }
\\modtwosum	{  print_unicode(0x2A0A); }
\\sumint	{  print_unicode(0x2A0B); }
\\iiiint	{  print_unicode(0x2A0C); }
\\intbar	{  print_unicode(0x2A0D); }
\\intBar	{  print_unicode(0x2A0E); }
\\fint	{  print_unicode(0x2A0F); }
\\cirfnint	{  print_unicode(0x2A10); }
\\awint	{  print_unicode(0x2A11); }
\\rppolint	{  print_unicode(0x2A12); }
\\scpolint	{  print_unicode(0x2A13); }
\\npolint	{  print_unicode(0x2A14); }
\\pointint	{  print_unicode(0x2A15); }
\\sqint	{  print_unicode(0x2A16); }
\\intlarhk	{  print_unicode(0x2A17); }
\\intx	{  print_unicode(0x2A18); }
\\intcap	{  print_unicode(0x2A19); }
\\intcup	{  print_unicode(0x2A1A); }
\\upint	{  print_unicode(0x2A1B); }
\\lowint	{  print_unicode(0x2A1C); }
\\Join	{  print_unicode(0x2A1D); }
\\bigtriangleleft	{  print_unicode(0x2A1E); }
\\zcmp	{  print_unicode(0x2A1F); }
\\zpipe	{  print_unicode(0x2A20); }
\\zproject	{  print_unicode(0x2A21); }
\\ringplus	{  print_unicode(0x2A22); }
\\plushat	{  print_unicode(0x2A23); }
\\simplus	{  print_unicode(0x2A24); }
\\plusdot	{  print_unicode(0x2A25); }
\\plussim	{  print_unicode(0x2A26); }
\\plussubtwo	{  print_unicode(0x2A27); }
\\plustrif	{  print_unicode(0x2A28); }
\\commaminus	{  print_unicode(0x2A29); }
\\minusdot	{  print_unicode(0x2A2A); }
\\minusfdots	{  print_unicode(0x2A2B); }
\\minusrdots	{  print_unicode(0x2A2C); }
\\opluslhrim	{  print_unicode(0x2A2D); }
\\oplusrhrim	{  print_unicode(0x2A2E); }
\\vectimes	{  print_unicode(0x2A2F); }
\\dottimes	{  print_unicode(0x2A30); }
\\timesbar	{  print_unicode(0x2A31); }
\\btimes	{  print_unicode(0x2A32); }
\\smashtimes	{  print_unicode(0x2A33); }
\\otimeslhrim	{  print_unicode(0x2A34); }
\\otimesrhrim	{  print_unicode(0x2A35); }
\\otimeshat	{  print_unicode(0x2A36); }
\\Otimes	{  print_unicode(0x2A37); }
\\odiv	{  print_unicode(0x2A38); }
\\triangleplus	{  print_unicode(0x2A39); }
\\triangleminus	{  print_unicode(0x2A3A); }
\\triangletimes	{  print_unicode(0x2A3B); }
\\intprod	{  print_unicode(0x2A3C); }
\\intprodr	{  print_unicode(0x2A3D); }
\\fcmp	{  print_unicode(0x2A3E); }
\\amalg	{  print_unicode(0x2A3F); }
\\capdot	{  print_unicode(0x2A40); }
\\uminus	{  print_unicode(0x2A41); }
\\barcup	{  print_unicode(0x2A42); }
\\barcap	{  print_unicode(0x2A43); }
\\capwedge	{  print_unicode(0x2A44); }
\\cupvee	{  print_unicode(0x2A45); }
\\cupovercap	{  print_unicode(0x2A46); }
\\capovercup	{  print_unicode(0x2A47); }
\\cupbarcap	{  print_unicode(0x2A48); }
\\capbarcup	{  print_unicode(0x2A49); }
\\twocups	{  print_unicode(0x2A4A); }
\\twocaps	{  print_unicode(0x2A4B); }
\\closedvarcup	{  print_unicode(0x2A4C); }
\\closedvarcap	{  print_unicode(0x2A4D); }
\\Sqcap	{  print_unicode(0x2A4E); }
\\Sqcup	{  print_unicode(0x2A4F); }
\\closedvarcupsmashprod	{  print_unicode(0x2A50); }
\\wedgeodot	{  print_unicode(0x2A51); }
\\veeodot	{  print_unicode(0x2A52); }
\\Wedge	{  print_unicode(0x2A53); }
\\Vee	{  print_unicode(0x2A54); }
\\wedgeonwedge	{  print_unicode(0x2A55); }
\\veeonvee	{  print_unicode(0x2A56); }
\\bigslopedvee	{  print_unicode(0x2A57); }
\\bigslopedwedge	{  print_unicode(0x2A58); }
\\veeonwedge	{  print_unicode(0x2A59); }
\\wedgemidvert	{  print_unicode(0x2A5A); }
\\veemidvert	{  print_unicode(0x2A5B); }
\\midbarwedge	{  print_unicode(0x2A5C); }
\\midbarvee	{  print_unicode(0x2A5D); }
\\doublebarwedge	{  print_unicode(0x2A5E); }
\\wedgebar	{  print_unicode(0x2A5F); }
\\wedgedoublebar	{  print_unicode(0x2A60); }
\\varveebar	{  print_unicode(0x2A61); }
\\doublebarvee	{  print_unicode(0x2A62); }
\\veedoublebar	{  print_unicode(0x2A63); }
\\dsub	{  print_unicode(0x2A64); }
\\rsub	{  print_unicode(0x2A65); }
\\eqdot	{  print_unicode(0x2A66); }
\\dotequiv	{  print_unicode(0x2A67); }
\\equivVert	{  print_unicode(0x2A68); }
\\equivVvert	{  print_unicode(0x2A69); }
\\dotsim	{  print_unicode(0x2A6A); }
\\simrdots	{  print_unicode(0x2A6B); }
\\simminussim	{  print_unicode(0x2A6C); }
\\congdot	{  print_unicode(0x2A6D); }
\\asteq	{  print_unicode(0x2A6E); }
\\hatapprox	{  print_unicode(0x2A6F); }
\\approxeqq	{  print_unicode(0x2A70); }
\\eqqplus	{  print_unicode(0x2A71); }
\\pluseqq	{  print_unicode(0x2A72); }
\\eqqsim	{  print_unicode(0x2A73); }
\\Coloneq	{  print_unicode(0x2A74); }
\\eqeq	{  print_unicode(0x2A75); }
\\eqeqeq	{  print_unicode(0x2A76); }
\\ddotseq	{  print_unicode(0x2A77); }
\\equivDD	{  print_unicode(0x2A78); }
\\ltcir	{  print_unicode(0x2A79); }
\\gtcir	{  print_unicode(0x2A7A); }
\\ltquest	{  print_unicode(0x2A7B); }
\\gtquest	{  print_unicode(0x2A7C); }
\\leqslant	{  print_unicode(0x2A7D); }
\\geqslant	{  print_unicode(0x2A7E); }
\\lesdot	{  print_unicode(0x2A7F); }
\\gesdot	{  print_unicode(0x2A80); }
\\lesdoto	{  print_unicode(0x2A81); }
\\gesdoto	{  print_unicode(0x2A82); }
\\lesdotor	{  print_unicode(0x2A83); }
\\gesdotol	{  print_unicode(0x2A84); }
\\lessapprox	{  print_unicode(0x2A85); }
\\gtrapprox	{  print_unicode(0x2A86); }
\\lneq	{  print_unicode(0x2A87); }
\\gneq	{  print_unicode(0x2A88); }
\\lnapprox	{  print_unicode(0x2A89); }
\\gnapprox	{  print_unicode(0x2A8A); }
\\lesseqqgtr	{  print_unicode(0x2A8B); }
\\gtreqqless	{  print_unicode(0x2A8C); }
\\lsime	{  print_unicode(0x2A8D); }
\\gsime	{  print_unicode(0x2A8E); }
\\lsimg	{  print_unicode(0x2A8F); }
\\gsiml	{  print_unicode(0x2A90); }
\\lgE	{  print_unicode(0x2A91); }
\\glE	{  print_unicode(0x2A92); }
\\lesges	{  print_unicode(0x2A93); }
\\gesles	{  print_unicode(0x2A94); }
\\eqslantless	{  print_unicode(0x2A95); }
\\eqslantgtr	{  print_unicode(0x2A96); }
\\elsdot	{  print_unicode(0x2A97); }
\\egsdot	{  print_unicode(0x2A98); }
\\eqqless	{  print_unicode(0x2A99); }
\\eqqgtr	{  print_unicode(0x2A9A); }
\\eqqslantless	{  print_unicode(0x2A9B); }
\\eqqslantgtr	{  print_unicode(0x2A9C); }
\\simless	{  print_unicode(0x2A9D); }
\\simgtr	{  print_unicode(0x2A9E); }
\\simlE	{  print_unicode(0x2A9F); }
\\simgE	{  print_unicode(0x2AA0); }
\\Lt	{  print_unicode(0x2AA1); }
\\Gt	{  print_unicode(0x2AA2); }
\\partialmeetcontraction	{  print_unicode(0x2AA3); }
\\glj	{  print_unicode(0x2AA4); }
\\gla	{  print_unicode(0x2AA5); }
\\ltcc	{  print_unicode(0x2AA6); }
\\gtcc	{  print_unicode(0x2AA7); }
\\lescc	{  print_unicode(0x2AA8); }
\\gescc	{  print_unicode(0x2AA9); }
\\smt	{  print_unicode(0x2AAA); }
\\lat	{  print_unicode(0x2AAB); }
\\smte	{  print_unicode(0x2AAC); }
\\late	{  print_unicode(0x2AAD); }
\\bumpeqq	{  print_unicode(0x2AAE); }
\\preceq	{  print_unicode(0x2AAF); }
\\succeq	{  print_unicode(0x2AB0); }
\\precneq	{  print_unicode(0x2AB1); }
\\succneq	{  print_unicode(0x2AB2); }
\\preceqq	{  print_unicode(0x2AB3); }
\\succeqq	{  print_unicode(0x2AB4); }
\\precneqq	{  print_unicode(0x2AB5); }
\\succneqq	{  print_unicode(0x2AB6); }
\\precapprox	{  print_unicode(0x2AB7); }
\\succapprox	{  print_unicode(0x2AB8); }
\\precnapprox	{  print_unicode(0x2AB9); }
\\succnapprox	{  print_unicode(0x2ABA); }
\\Prec	{  print_unicode(0x2ABB); }
\\Succ	{  print_unicode(0x2ABC); }
\\subsetdot	{  print_unicode(0x2ABD); }
\\supsetdot	{  print_unicode(0x2ABE); }
\\subsetplus	{  print_unicode(0x2ABF); }
\\supsetplus	{  print_unicode(0x2AC0); }
\\submult	{  print_unicode(0x2AC1); }
\\supmult	{  print_unicode(0x2AC2); }
\\subedot	{  print_unicode(0x2AC3); }
\\supedot	{  print_unicode(0x2AC4); }
\\subseteqq	{  print_unicode(0x2AC5); }
\\supseteqq	{  print_unicode(0x2AC6); }
\\subsim	{  print_unicode(0x2AC7); }
\\supsim	{  print_unicode(0x2AC8); }
\\subsetapprox	{  print_unicode(0x2AC9); }
\\supsetapprox	{  print_unicode(0x2ACA); }
\\subsetneqq	{  print_unicode(0x2ACB); }
\\supsetneqq	{  print_unicode(0x2ACC); }
\\lsqhook	{  print_unicode(0x2ACD); }
\\rsqhook	{  print_unicode(0x2ACE); }
\\csub	{  print_unicode(0x2ACF); }
\\csup	{  print_unicode(0x2AD0); }
\\csube	{  print_unicode(0x2AD1); }
\\csupe	{  print_unicode(0x2AD2); }
\\subsup	{  print_unicode(0x2AD3); }
\\supsub	{  print_unicode(0x2AD4); }
\\subsub	{  print_unicode(0x2AD5); }
\\supsup	{  print_unicode(0x2AD6); }
\\suphsub	{  print_unicode(0x2AD7); }
\\supdsub	{  print_unicode(0x2AD8); }
\\forkv	{  print_unicode(0x2AD9); }
\\topfork	{  print_unicode(0x2ADA); }
\\mlcp	{  print_unicode(0x2ADB); }
\\forks	{  print_unicode(0x2ADC); }
\\forksnot	{  print_unicode(0x2ADD); }
\\shortlefttack	{  print_unicode(0x2ADE); }
\\shortdowntack	{  print_unicode(0x2ADF); }
\\shortuptack	{  print_unicode(0x2AE0); }
\\perps	{  print_unicode(0x2AE1); }
\\vDdash	{  print_unicode(0x2AE2); }
\\dashV	{  print_unicode(0x2AE3); }
\\Dashv	{  print_unicode(0x2AE4); }
\\DashV	{  print_unicode(0x2AE5); }
\\varVdash	{  print_unicode(0x2AE6); }
\\Barv	{  print_unicode(0x2AE7); }
\\vBar	{  print_unicode(0x2AE8); }
\\vBarv	{  print_unicode(0x2AE9); }
\\barV	{  print_unicode(0x2AEA); }
\\Vbar	{  print_unicode(0x2AEB); }
\\Not	{  print_unicode(0x2AEC); }
\\bNot	{  print_unicode(0x2AED); }
\\revnmid	{  print_unicode(0x2AEE); }
\\cirmid	{  print_unicode(0x2AEF); }
\\midcir	{  print_unicode(0x2AF0); }
\\topcir	{  print_unicode(0x2AF1); }
\\nhpar	{  print_unicode(0x2AF2); }
\\parsim	{  print_unicode(0x2AF3); }
\\interleave	{  print_unicode(0x2AF4); }
\\nhVvert	{  print_unicode(0x2AF5); }
\\threedotcolon	{  print_unicode(0x2AF6); }
\\lllnest	{  print_unicode(0x2AF7); }
\\gggnest	{  print_unicode(0x2AF8); }
\\leqqslant	{  print_unicode(0x2AF9); }
\\geqqslant	{  print_unicode(0x2AFA); }
\\trslash	{  print_unicode(0x2AFB); }
\\biginterleave	{  print_unicode(0x2AFC); }
\\sslash	{  print_unicode(0x2AFD); }
\\talloblong	{  print_unicode(0x2AFE); }
\\bigtalloblong	{  print_unicode(0x2AFF); }
\\squaretopblack	{  print_unicode(0x2B12); }
\\squarebotblack	{  print_unicode(0x2B13); }
\\squareurblack	{  print_unicode(0x2B14); }
\\squarellblack	{  print_unicode(0x2B15); }
\\diamondleftblack	{  print_unicode(0x2B16); }
\\diamondrightblack	{  print_unicode(0x2B17); }
\\diamondtopblack	{  print_unicode(0x2B18); }
\\diamondbotblack	{  print_unicode(0x2B19); }
\\dottedsquare	{  print_unicode(0x2B1A); }
\\lgblksquare	{  print_unicode(0x2B1B); }
\\lgwhtsquare	{  print_unicode(0x2B1C); }
\\vysmblksquare	{  print_unicode(0x2B1D); }
\\vysmwhtsquare	{  print_unicode(0x2B1E); }
\\pentagonblack	{  print_unicode(0x2B1F); }
\\pentagon	{  print_unicode(0x2B20); }
\\varhexagon	{  print_unicode(0x2B21); }
\\varhexagonblack	{  print_unicode(0x2B22); }
\\hexagonblack	{  print_unicode(0x2B23); }
\\lgblkcircle	{  print_unicode(0x2B24); }
\\mdblkdiamond	{  print_unicode(0x2B25); }
\\mdwhtdiamond	{  print_unicode(0x2B26); }
\\mdblklozenge	{  print_unicode(0x2B27); }
\\mdwhtlozenge	{  print_unicode(0x2B28); }
\\smblkdiamond	{  print_unicode(0x2B29); }
\\smblklozenge	{  print_unicode(0x2B2A); }
\\smwhtlozenge	{  print_unicode(0x2B2B); }
\\blkhorzoval	{  print_unicode(0x2B2C); }
\\whthorzoval	{  print_unicode(0x2B2D); }
\\blkvertoval	{  print_unicode(0x2B2E); }
\\whtvertoval	{  print_unicode(0x2B2F); }
\\circleonleftarrow	{  print_unicode(0x2B30); }
\\leftthreearrows	{  print_unicode(0x2B31); }
\\leftarrowonoplus	{  print_unicode(0x2B32); }
\\longleftsquigarrow	{  print_unicode(0x2B33); }
\\nvtwoheadleftarrow	{  print_unicode(0x2B34); }
\\nVtwoheadleftarrow	{  print_unicode(0x2B35); }
\\twoheadmapsfrom	{  print_unicode(0x2B36); }
\\twoheadleftdbkarrow	{  print_unicode(0x2B37); }
\\leftdotarrow	{  print_unicode(0x2B38); }
\\nvleftarrowtail	{  print_unicode(0x2B39); }
\\nVleftarrowtail	{  print_unicode(0x2B3A); }
\\twoheadleftarrowtail	{  print_unicode(0x2B3B); }
\\nvtwoheadleftarrowtail	{  print_unicode(0x2B3C); }
\\nVtwoheadleftarrowtail	{  print_unicode(0x2B3D); }
\\leftarrowx	{  print_unicode(0x2B3E); }
\\leftcurvedarrow	{  print_unicode(0x2B3F); }
\\equalleftarrow	{  print_unicode(0x2B40); }
\\bsimilarleftarrow	{  print_unicode(0x2B41); }
\\leftarrowbackapprox	{  print_unicode(0x2B42); }
\\rightarrowgtr	{  print_unicode(0x2B43); }
\\rightarrowsupset	{  print_unicode(0x2B44); }
\\LLeftarrow	{  print_unicode(0x2B45); }
\\RRightarrow	{  print_unicode(0x2B46); }
\\bsimilarrightarrow	{  print_unicode(0x2B47); }
\\rightarrowbackapprox	{  print_unicode(0x2B48); }
\\similarleftarrow	{  print_unicode(0x2B49); }
\\leftarrowapprox	{  print_unicode(0x2B4A); }
\\leftarrowbsimilar	{  print_unicode(0x2B4B); }
\\rightarrowbsimilar	{  print_unicode(0x2B4C); }
\\medwhitestar	{  print_unicode(0x2B50); }
\\medblackstar	{  print_unicode(0x2B51); }
\\smwhitestar	{  print_unicode(0x2B52); }
\\rightpentagonblack	{  print_unicode(0x2B53); }
\\rightpentagon	{  print_unicode(0x2B54); }
\\postalmark	{  print_unicode(0x3012); }
\\hzigzag	{  print_unicode(0x3030); }
\\mbfA	{  print_unicode(0xD400); }
\\mbfB	{  print_unicode(0xD401); }
\\mbfC	{  print_unicode(0xD402); }
\\mbfD	{  print_unicode(0xD403); }
\\mbfE	{  print_unicode(0xD404); }
\\mbfF	{  print_unicode(0xD405); }
\\mbfG	{  print_unicode(0xD406); }
\\mbfH	{  print_unicode(0xD407); }
\\mbfI	{  print_unicode(0xD408); }
\\mbfJ	{  print_unicode(0xD409); }
\\mbfK	{  print_unicode(0xD40A); }
\\mbfL	{  print_unicode(0xD40B); }
\\mbfM	{  print_unicode(0xD40C); }
\\mbfN	{  print_unicode(0xD40D); }
\\mbfO	{  print_unicode(0xD40E); }
\\mbfP	{  print_unicode(0xD40F); }
\\mbfQ	{  print_unicode(0xD410); }
\\mbfR	{  print_unicode(0xD411); }
\\mbfS	{  print_unicode(0xD412); }
\\mbfT	{  print_unicode(0xD413); }
\\mbfU	{  print_unicode(0xD414); }
\\mbfV	{  print_unicode(0xD415); }
\\mbfW	{  print_unicode(0xD416); }
\\mbfX	{  print_unicode(0xD417); }
\\mbfY	{  print_unicode(0xD418); }
\\mbfZ	{  print_unicode(0xD419); }
\\mbfa	{  print_unicode(0xD41A); }
\\mbfb	{  print_unicode(0xD41B); }
\\mbfc	{  print_unicode(0xD41C); }
\\mbfd	{  print_unicode(0xD41D); }
\\mbfe	{  print_unicode(0xD41E); }
\\mbff	{  print_unicode(0xD41F); }
\\mbfg	{  print_unicode(0xD420); }
\\mbfh	{  print_unicode(0xD421); }
\\mbfi	{  print_unicode(0xD422); }
\\mbfj	{  print_unicode(0xD423); }
\\mbfk	{  print_unicode(0xD424); }
\\mbfl	{  print_unicode(0xD425); }
\\mbfm	{  print_unicode(0xD426); }
\\mbfn	{  print_unicode(0xD427); }
\\mbfo	{  print_unicode(0xD428); }
\\mbfp	{  print_unicode(0xD429); }
\\mbfq	{  print_unicode(0xD42A); }
\\mbfr	{  print_unicode(0xD42B); }
\\mbfs	{  print_unicode(0xD42C); }
\\mbft	{  print_unicode(0xD42D); }
\\mbfu	{  print_unicode(0xD42E); }
\\mbfv	{  print_unicode(0xD42F); }
\\mbfw	{  print_unicode(0xD430); }
\\mbfx	{  print_unicode(0xD431); }
\\mbfy	{  print_unicode(0xD432); }
\\mbfz	{  print_unicode(0xD433); }
\\mitA	{  print_unicode(0xD434); }
\\mitB	{  print_unicode(0xD435); }
\\mitC	{  print_unicode(0xD436); }
\\mitD	{  print_unicode(0xD437); }
\\mitE	{  print_unicode(0xD438); }
\\mitF	{  print_unicode(0xD439); }
\\mitG	{  print_unicode(0xD43A); }
\\mitH	{  print_unicode(0xD43B); }
\\mitI	{  print_unicode(0xD43C); }
\\mitJ	{  print_unicode(0xD43D); }
\\mitK	{  print_unicode(0xD43E); }
\\mitL	{  print_unicode(0xD43F); }
\\mitM	{  print_unicode(0xD440); }
\\mitN	{  print_unicode(0xD441); }
\\mitO	{  print_unicode(0xD442); }
\\mitP	{  print_unicode(0xD443); }
\\mitQ	{  print_unicode(0xD444); }
\\mitR	{  print_unicode(0xD445); }
\\mitS	{  print_unicode(0xD446); }
\\mitT	{  print_unicode(0xD447); }
\\mitU	{  print_unicode(0xD448); }
\\mitV	{  print_unicode(0xD449); }
\\mitW	{  print_unicode(0xD44A); }
\\mitX	{  print_unicode(0xD44B); }
\\mitY	{  print_unicode(0xD44C); }
\\mitZ	{  print_unicode(0xD44D); }
\\mita	{  print_unicode(0xD44E); }
\\mitb	{  print_unicode(0xD44F); }
\\mitc	{  print_unicode(0xD450); }
\\mitd	{  print_unicode(0xD451); }
\\mite	{  print_unicode(0xD452); }
\\mitf	{  print_unicode(0xD453); }
\\mitg	{  print_unicode(0xD454); }
\\miti	{  print_unicode(0xD456); }
\\mitj	{  print_unicode(0xD457); }
\\mitk	{  print_unicode(0xD458); }
\\mitl	{  print_unicode(0xD459); }
\\mitm	{  print_unicode(0xD45A); }
\\mitn	{  print_unicode(0xD45B); }
\\mito	{  print_unicode(0xD45C); }
\\mitp	{  print_unicode(0xD45D); }
\\mitq	{  print_unicode(0xD45E); }
\\mitr	{  print_unicode(0xD45F); }
\\mits	{  print_unicode(0xD460); }
\\mitt	{  print_unicode(0xD461); }
\\mitu	{  print_unicode(0xD462); }
\\mitv	{  print_unicode(0xD463); }
\\mitw	{  print_unicode(0xD464); }
\\mitx	{  print_unicode(0xD465); }
\\mity	{  print_unicode(0xD466); }
\\mitz	{  print_unicode(0xD467); }
\\mbfitA	{  print_unicode(0xD468); }
\\mbfitB	{  print_unicode(0xD469); }
\\mbfitC	{  print_unicode(0xD46A); }
\\mbfitD	{  print_unicode(0xD46B); }
\\mbfitE	{  print_unicode(0xD46C); }
\\mbfitF	{  print_unicode(0xD46D); }
\\mbfitG	{  print_unicode(0xD46E); }
\\mbfitH	{  print_unicode(0xD46F); }
\\mbfitI	{  print_unicode(0xD470); }
\\mbfitJ	{  print_unicode(0xD471); }
\\mbfitK	{  print_unicode(0xD472); }
\\mbfitL	{  print_unicode(0xD473); }
\\mbfitM	{  print_unicode(0xD474); }
\\mbfitN	{  print_unicode(0xD475); }
\\mbfitO	{  print_unicode(0xD476); }
\\mbfitP	{  print_unicode(0xD477); }
\\mbfitQ	{  print_unicode(0xD478); }
\\mbfitR	{  print_unicode(0xD479); }
\\mbfitS	{  print_unicode(0xD47A); }
\\mbfitT	{  print_unicode(0xD47B); }
\\mbfitU	{  print_unicode(0xD47C); }
\\mbfitV	{  print_unicode(0xD47D); }
\\mbfitW	{  print_unicode(0xD47E); }
\\mbfitX	{  print_unicode(0xD47F); }
\\mbfitY	{  print_unicode(0xD480); }
\\mbfitZ	{  print_unicode(0xD481); }
\\mbfita	{  print_unicode(0xD482); }
\\mbfitb	{  print_unicode(0xD483); }
\\mbfitc	{  print_unicode(0xD484); }
\\mbfitd	{  print_unicode(0xD485); }
\\mbfite	{  print_unicode(0xD486); }
\\mbfitf	{  print_unicode(0xD487); }
\\mbfitg	{  print_unicode(0xD488); }
\\mbfith	{  print_unicode(0xD489); }
\\mbfiti	{  print_unicode(0xD48A); }
\\mbfitj	{  print_unicode(0xD48B); }
\\mbfitk	{  print_unicode(0xD48C); }
\\mbfitl	{  print_unicode(0xD48D); }
\\mbfitm	{  print_unicode(0xD48E); }
\\mbfitn	{  print_unicode(0xD48F); }
\\mbfito	{  print_unicode(0xD490); }
\\mbfitp	{  print_unicode(0xD491); }
\\mbfitq	{  print_unicode(0xD492); }
\\mbfitr	{  print_unicode(0xD493); }
\\mbfits	{  print_unicode(0xD494); }
\\mbfitt	{  print_unicode(0xD495); }
\\mbfitu	{  print_unicode(0xD496); }
\\mbfitv	{  print_unicode(0xD497); }
\\mbfitw	{  print_unicode(0xD498); }
\\mbfitx	{  print_unicode(0xD499); }
\\mbfity	{  print_unicode(0xD49A); }
\\mbfitz	{  print_unicode(0xD49B); }
\\mscrA	{  print_unicode(0xD49C); }
\\mscrC	{  print_unicode(0xD49E); }
\\mscrD	{  print_unicode(0xD49F); }
\\mscrG	{  print_unicode(0xD4A2); }
\\mscrJ	{  print_unicode(0xD4A5); }
\\mscrK	{  print_unicode(0xD4A6); }
\\mscrN	{  print_unicode(0xD4A9); }
\\mscrO	{  print_unicode(0xD4AA); }
\\mscrP	{  print_unicode(0xD4AB); }
\\mscrQ	{  print_unicode(0xD4AC); }
\\mscrS	{  print_unicode(0xD4AE); }
\\mscrT	{  print_unicode(0xD4AF); }
\\mscrU	{  print_unicode(0xD4B0); }
\\mscrV	{  print_unicode(0xD4B1); }
\\mscrW	{  print_unicode(0xD4B2); }
\\mscrX	{  print_unicode(0xD4B3); }
\\mscrY	{  print_unicode(0xD4B4); }
\\mscrZ	{  print_unicode(0xD4B5); }
\\mscra	{  print_unicode(0xD4B6); }
\\mscrb	{  print_unicode(0xD4B7); }
\\mscrc	{  print_unicode(0xD4B8); }
\\mscrd	{  print_unicode(0xD4B9); }
\\mscrf	{  print_unicode(0xD4BB); }
\\mscrh	{  print_unicode(0xD4BD); }
\\mscri	{  print_unicode(0xD4BE); }
\\mscrj	{  print_unicode(0xD4BF); }
\\mscrk	{  print_unicode(0xD4C0); }
\\mscrl	{  print_unicode(0xD4C1); }
\\mscrm	{  print_unicode(0xD4C2); }
\\mscrn	{  print_unicode(0xD4C3); }
\\mscrp	{  print_unicode(0xD4C5); }
\\mscrq	{  print_unicode(0xD4C6); }
\\mscrr	{  print_unicode(0xD4C7); }
\\mscrs	{  print_unicode(0xD4C8); }
\\mscrt	{  print_unicode(0xD4C9); }
\\mscru	{  print_unicode(0xD4CA); }
\\mscrv	{  print_unicode(0xD4CB); }
\\mscrw	{  print_unicode(0xD4CC); }
\\mscrx	{  print_unicode(0xD4CD); }
\\mscry	{  print_unicode(0xD4CE); }
\\mscrz	{  print_unicode(0xD4CF); }
\\mbfscrA	{  print_unicode(0xD4D0); }
\\mbfscrB	{  print_unicode(0xD4D1); }
\\mbfscrC	{  print_unicode(0xD4D2); }
\\mbfscrD	{  print_unicode(0xD4D3); }
\\mbfscrE	{  print_unicode(0xD4D4); }
\\mbfscrF	{  print_unicode(0xD4D5); }
\\mbfscrG	{  print_unicode(0xD4D6); }
\\mbfscrH	{  print_unicode(0xD4D7); }
\\mbfscrI	{  print_unicode(0xD4D8); }
\\mbfscrJ	{  print_unicode(0xD4D9); }
\\mbfscrK	{  print_unicode(0xD4DA); }
\\mbfscrL	{  print_unicode(0xD4DB); }
\\mbfscrM	{  print_unicode(0xD4DC); }
\\mbfscrN	{  print_unicode(0xD4DD); }
\\mbfscrO	{  print_unicode(0xD4DE); }
\\mbfscrP	{  print_unicode(0xD4DF); }
\\mbfscrQ	{  print_unicode(0xD4E0); }
\\mbfscrR	{  print_unicode(0xD4E1); }
\\mbfscrS	{  print_unicode(0xD4E2); }
\\mbfscrT	{  print_unicode(0xD4E3); }
\\mbfscrU	{  print_unicode(0xD4E4); }
\\mbfscrV	{  print_unicode(0xD4E5); }
\\mbfscrW	{  print_unicode(0xD4E6); }
\\mbfscrX	{  print_unicode(0xD4E7); }
\\mbfscrY	{  print_unicode(0xD4E8); }
\\mbfscrZ	{  print_unicode(0xD4E9); }
\\mbfscra	{  print_unicode(0xD4EA); }
\\mbfscrb	{  print_unicode(0xD4EB); }
\\mbfscrc	{  print_unicode(0xD4EC); }
\\mbfscrd	{  print_unicode(0xD4ED); }
\\mbfscre	{  print_unicode(0xD4EE); }
\\mbfscrf	{  print_unicode(0xD4EF); }
\\mbfscrg	{  print_unicode(0xD4F0); }
\\mbfscrh	{  print_unicode(0xD4F1); }
\\mbfscri	{  print_unicode(0xD4F2); }
\\mbfscrj	{  print_unicode(0xD4F3); }
\\mbfscrk	{  print_unicode(0xD4F4); }
\\mbfscrl	{  print_unicode(0xD4F5); }
\\mbfscrm	{  print_unicode(0xD4F6); }
\\mbfscrn	{  print_unicode(0xD4F7); }
\\mbfscro	{  print_unicode(0xD4F8); }
\\mbfscrp	{  print_unicode(0xD4F9); }
\\mbfscrq	{  print_unicode(0xD4FA); }
\\mbfscrr	{  print_unicode(0xD4FB); }
\\mbfscrs	{  print_unicode(0xD4FC); }
\\mbfscrt	{  print_unicode(0xD4FD); }
\\mbfscru	{  print_unicode(0xD4FE); }
\\mbfscrv	{  print_unicode(0xD4FF); }
\\mbfscrw	{  print_unicode(0xD500); }
\\mbfscrx	{  print_unicode(0xD501); }
\\mbfscry	{  print_unicode(0xD502); }
\\mbfscrz	{  print_unicode(0xD503); }
\\mfrakA	{  print_unicode(0xD504); }
\\mfrakB	{  print_unicode(0xD505); }
\\mfrakD	{  print_unicode(0xD507); }
\\mfrakE	{  print_unicode(0xD508); }
\\mfrakF	{  print_unicode(0xD509); }
\\mfrakG	{  print_unicode(0xD50A); }
\\mfrakJ	{  print_unicode(0xD50D); }
\\mfrakK	{  print_unicode(0xD50E); }
\\mfrakL	{  print_unicode(0xD50F); }
\\mfrakM	{  print_unicode(0xD510); }
\\mfrakN	{  print_unicode(0xD511); }
\\mfrakO	{  print_unicode(0xD512); }
\\mfrakP	{  print_unicode(0xD513); }
\\mfrakQ	{  print_unicode(0xD514); }
\\mfrakS	{  print_unicode(0xD516); }
\\mfrakT	{  print_unicode(0xD517); }
\\mfrakU	{  print_unicode(0xD518); }
\\mfrakV	{  print_unicode(0xD519); }
\\mfrakW	{  print_unicode(0xD51A); }
\\mfrakX	{  print_unicode(0xD51B); }
\\mfrakY	{  print_unicode(0xD51C); }
\\mfraka	{  print_unicode(0xD51E); }
\\mfrakb	{  print_unicode(0xD51F); }
\\mfrakc	{  print_unicode(0xD520); }
\\mfrakd	{  print_unicode(0xD521); }
\\mfrake	{  print_unicode(0xD522); }
\\mfrakf	{  print_unicode(0xD523); }
\\mfrakg	{  print_unicode(0xD524); }
\\mfrakh	{  print_unicode(0xD525); }
\\mfraki	{  print_unicode(0xD526); }
\\mfrakj	{  print_unicode(0xD527); }
\\mfrakk	{  print_unicode(0xD528); }
\\mfrakl	{  print_unicode(0xD529); }
\\mfrakm	{  print_unicode(0xD52A); }
\\mfrakn	{  print_unicode(0xD52B); }
\\mfrako	{  print_unicode(0xD52C); }
\\mfrakp	{  print_unicode(0xD52D); }
\\mfrakq	{  print_unicode(0xD52E); }
\\mfrakr	{  print_unicode(0xD52F); }
\\mfraks	{  print_unicode(0xD530); }
\\mfrakt	{  print_unicode(0xD531); }
\\mfraku	{  print_unicode(0xD532); }
\\mfrakv	{  print_unicode(0xD533); }
\\mfrakw	{  print_unicode(0xD534); }
\\mfrakx	{  print_unicode(0xD535); }
\\mfraky	{  print_unicode(0xD536); }
\\mfrakz	{  print_unicode(0xD537); }
\\BbbA	{  print_unicode(0xD538); }
\\BbbB	{  print_unicode(0xD539); }
\\BbbD	{  print_unicode(0xD53B); }
\\BbbE	{  print_unicode(0xD53C); }
\\BbbF	{  print_unicode(0xD53D); }
\\BbbG	{  print_unicode(0xD53E); }
\\BbbI	{  print_unicode(0xD540); }
\\BbbJ	{  print_unicode(0xD541); }
\\BbbK	{  print_unicode(0xD542); }
\\BbbL	{  print_unicode(0xD543); }
\\BbbM	{  print_unicode(0xD544); }
\\BbbO	{  print_unicode(0xD546); }
\\BbbS	{  print_unicode(0xD54A); }
\\BbbT	{  print_unicode(0xD54B); }
\\BbbU	{  print_unicode(0xD54C); }
\\BbbV	{  print_unicode(0xD54D); }
\\BbbW	{  print_unicode(0xD54E); }
\\BbbX	{  print_unicode(0xD54F); }
\\BbbY	{  print_unicode(0xD550); }
\\Bbba	{  print_unicode(0xD552); }
\\Bbbb	{  print_unicode(0xD553); }
\\Bbbc	{  print_unicode(0xD554); }
\\Bbbd	{  print_unicode(0xD555); }
\\Bbbe	{  print_unicode(0xD556); }
\\Bbbf	{  print_unicode(0xD557); }
\\Bbbg	{  print_unicode(0xD558); }
\\Bbbh	{  print_unicode(0xD559); }
\\Bbbi	{  print_unicode(0xD55A); }
\\Bbbj	{  print_unicode(0xD55B); }
\\Bbbk	{  print_unicode(0xD55C); }
\\Bbbl	{  print_unicode(0xD55D); }
\\Bbbm	{  print_unicode(0xD55E); }
\\Bbbn	{  print_unicode(0xD55F); }
\\Bbbo	{  print_unicode(0xD560); }
\\Bbbp	{  print_unicode(0xD561); }
\\Bbbq	{  print_unicode(0xD562); }
\\Bbbr	{  print_unicode(0xD563); }
\\Bbbs	{  print_unicode(0xD564); }
\\Bbbt	{  print_unicode(0xD565); }
\\Bbbu	{  print_unicode(0xD566); }
\\Bbbv	{  print_unicode(0xD567); }
\\Bbbw	{  print_unicode(0xD568); }
\\Bbbx	{  print_unicode(0xD569); }
\\Bbby	{  print_unicode(0xD56A); }
\\Bbbz	{  print_unicode(0xD56B); }
\\mbffrakA	{  print_unicode(0xD56C); }
\\mbffrakB	{  print_unicode(0xD56D); }
\\mbffrakC	{  print_unicode(0xD56E); }
\\mbffrakD	{  print_unicode(0xD56F); }
\\mbffrakE	{  print_unicode(0xD570); }
\\mbffrakF	{  print_unicode(0xD571); }
\\mbffrakG	{  print_unicode(0xD572); }
\\mbffrakH	{  print_unicode(0xD573); }
\\mbffrakI	{  print_unicode(0xD574); }
\\mbffrakJ	{  print_unicode(0xD575); }
\\mbffrakK	{  print_unicode(0xD576); }
\\mbffrakL	{  print_unicode(0xD577); }
\\mbffrakM	{  print_unicode(0xD578); }
\\mbffrakN	{  print_unicode(0xD579); }
\\mbffrakO	{  print_unicode(0xD57A); }
\\mbffrakP	{  print_unicode(0xD57B); }
\\mbffrakQ	{  print_unicode(0xD57C); }
\\mbffrakR	{  print_unicode(0xD57D); }
\\mbffrakS	{  print_unicode(0xD57E); }
\\mbffrakT	{  print_unicode(0xD57F); }
\\mbffrakU	{  print_unicode(0xD580); }
\\mbffrakV	{  print_unicode(0xD581); }
\\mbffrakW	{  print_unicode(0xD582); }
\\mbffrakX	{  print_unicode(0xD583); }
\\mbffrakY	{  print_unicode(0xD584); }
\\mbffrakZ	{  print_unicode(0xD585); }
\\mbffraka	{  print_unicode(0xD586); }
\\mbffrakb	{  print_unicode(0xD587); }
\\mbffrakc	{  print_unicode(0xD588); }
\\mbffrakd	{  print_unicode(0xD589); }
\\mbffrake	{  print_unicode(0xD58A); }
\\mbffrakf	{  print_unicode(0xD58B); }
\\mbffrakg	{  print_unicode(0xD58C); }
\\mbffrakh	{  print_unicode(0xD58D); }
\\mbffraki	{  print_unicode(0xD58E); }
\\mbffrakj	{  print_unicode(0xD58F); }
\\mbffrakk	{  print_unicode(0xD590); }
\\mbffrakl	{  print_unicode(0xD591); }
\\mbffrakm	{  print_unicode(0xD592); }
\\mbffrakn	{  print_unicode(0xD593); }
\\mbffrako	{  print_unicode(0xD594); }
\\mbffrakp	{  print_unicode(0xD595); }
\\mbffrakq	{  print_unicode(0xD596); }
\\mbffrakr	{  print_unicode(0xD597); }
\\mbffraks	{  print_unicode(0xD598); }
\\mbffrakt	{  print_unicode(0xD599); }
\\mbffraku	{  print_unicode(0xD59A); }
\\mbffrakv	{  print_unicode(0xD59B); }
\\mbffrakw	{  print_unicode(0xD59C); }
\\mbffrakx	{  print_unicode(0xD59D); }
\\mbffraky	{  print_unicode(0xD59E); }
\\mbffrakz	{  print_unicode(0xD59F); }
\\msansA	{  print_unicode(0xD5A0); }
\\msansB	{  print_unicode(0xD5A1); }
\\msansC	{  print_unicode(0xD5A2); }
\\msansD	{  print_unicode(0xD5A3); }
\\msansE	{  print_unicode(0xD5A4); }
\\msansF	{  print_unicode(0xD5A5); }
\\msansG	{  print_unicode(0xD5A6); }
\\msansH	{  print_unicode(0xD5A7); }
\\msansI	{  print_unicode(0xD5A8); }
\\msansJ	{  print_unicode(0xD5A9); }
\\msansK	{  print_unicode(0xD5AA); }
\\msansL	{  print_unicode(0xD5AB); }
\\msansM	{  print_unicode(0xD5AC); }
\\msansN	{  print_unicode(0xD5AD); }
\\msansO	{  print_unicode(0xD5AE); }
\\msansP	{  print_unicode(0xD5AF); }
\\msansQ	{  print_unicode(0xD5B0); }
\\msansR	{  print_unicode(0xD5B1); }
\\msansS	{  print_unicode(0xD5B2); }
\\msansT	{  print_unicode(0xD5B3); }
\\msansU	{  print_unicode(0xD5B4); }
\\msansV	{  print_unicode(0xD5B5); }
\\msansW	{  print_unicode(0xD5B6); }
\\msansX	{  print_unicode(0xD5B7); }
\\msansY	{  print_unicode(0xD5B8); }
\\msansZ	{  print_unicode(0xD5B9); }
\\msansa	{  print_unicode(0xD5BA); }
\\msansb	{  print_unicode(0xD5BB); }
\\msansc	{  print_unicode(0xD5BC); }
\\msansd	{  print_unicode(0xD5BD); }
\\msanse	{  print_unicode(0xD5BE); }
\\msansf	{  print_unicode(0xD5BF); }
\\msansg	{  print_unicode(0xD5C0); }
\\msansh	{  print_unicode(0xD5C1); }
\\msansi	{  print_unicode(0xD5C2); }
\\msansj	{  print_unicode(0xD5C3); }
\\msansk	{  print_unicode(0xD5C4); }
\\msansl	{  print_unicode(0xD5C5); }
\\msansm	{  print_unicode(0xD5C6); }
\\msansn	{  print_unicode(0xD5C7); }
\\msanso	{  print_unicode(0xD5C8); }
\\msansp	{  print_unicode(0xD5C9); }
\\msansq	{  print_unicode(0xD5CA); }
\\msansr	{  print_unicode(0xD5CB); }
\\msanss	{  print_unicode(0xD5CC); }
\\msanst	{  print_unicode(0xD5CD); }
\\msansu	{  print_unicode(0xD5CE); }
\\msansv	{  print_unicode(0xD5CF); }
\\msansw	{  print_unicode(0xD5D0); }
\\msansx	{  print_unicode(0xD5D1); }
\\msansy	{  print_unicode(0xD5D2); }
\\msansz	{  print_unicode(0xD5D3); }
\\mbfsansA	{  print_unicode(0xD5D4); }
\\mbfsansB	{  print_unicode(0xD5D5); }
\\mbfsansC	{  print_unicode(0xD5D6); }
\\mbfsansD	{  print_unicode(0xD5D7); }
\\mbfsansE	{  print_unicode(0xD5D8); }
\\mbfsansF	{  print_unicode(0xD5D9); }
\\mbfsansG	{  print_unicode(0xD5DA); }
\\mbfsansH	{  print_unicode(0xD5DB); }
\\mbfsansI	{  print_unicode(0xD5DC); }
\\mbfsansJ	{  print_unicode(0xD5DD); }
\\mbfsansK	{  print_unicode(0xD5DE); }
\\mbfsansL	{  print_unicode(0xD5DF); }
\\mbfsansM	{  print_unicode(0xD5E0); }
\\mbfsansN	{  print_unicode(0xD5E1); }
\\mbfsansO	{  print_unicode(0xD5E2); }
\\mbfsansP	{  print_unicode(0xD5E3); }
\\mbfsansQ	{  print_unicode(0xD5E4); }
\\mbfsansR	{  print_unicode(0xD5E5); }
\\mbfsansS	{  print_unicode(0xD5E6); }
\\mbfsansT	{  print_unicode(0xD5E7); }
\\mbfsansU	{  print_unicode(0xD5E8); }
\\mbfsansV	{  print_unicode(0xD5E9); }
\\mbfsansW	{  print_unicode(0xD5EA); }
\\mbfsansX	{  print_unicode(0xD5EB); }
\\mbfsansY	{  print_unicode(0xD5EC); }
\\mbfsansZ	{  print_unicode(0xD5ED); }
\\mbfsansa	{  print_unicode(0xD5EE); }
\\mbfsansb	{  print_unicode(0xD5EF); }
\\mbfsansc	{  print_unicode(0xD5F0); }
\\mbfsansd	{  print_unicode(0xD5F1); }
\\mbfsanse	{  print_unicode(0xD5F2); }
\\mbfsansf	{  print_unicode(0xD5F3); }
\\mbfsansg	{  print_unicode(0xD5F4); }
\\mbfsansh	{  print_unicode(0xD5F5); }
\\mbfsansi	{  print_unicode(0xD5F6); }
\\mbfsansj	{  print_unicode(0xD5F7); }
\\mbfsansk	{  print_unicode(0xD5F8); }
\\mbfsansl	{  print_unicode(0xD5F9); }
\\mbfsansm	{  print_unicode(0xD5FA); }
\\mbfsansn	{  print_unicode(0xD5FB); }
\\mbfsanso	{  print_unicode(0xD5FC); }
\\mbfsansp	{  print_unicode(0xD5FD); }
\\mbfsansq	{  print_unicode(0xD5FE); }
\\mbfsansr	{  print_unicode(0xD5FF); }
\\mbfsanss	{  print_unicode(0xD600); }
\\mbfsanst	{  print_unicode(0xD601); }
\\mbfsansu	{  print_unicode(0xD602); }
\\mbfsansv	{  print_unicode(0xD603); }
\\mbfsansw	{  print_unicode(0xD604); }
\\mbfsansx	{  print_unicode(0xD605); }
\\mbfsansy	{  print_unicode(0xD606); }
\\mbfsansz	{  print_unicode(0xD607); }
\\mitsansA	{  print_unicode(0xD608); }
\\mitsansB	{  print_unicode(0xD609); }
\\mitsansC	{  print_unicode(0xD60A); }
\\mitsansD	{  print_unicode(0xD60B); }
\\mitsansE	{  print_unicode(0xD60C); }
\\mitsansF	{  print_unicode(0xD60D); }
\\mitsansG	{  print_unicode(0xD60E); }
\\mitsansH	{  print_unicode(0xD60F); }
\\mitsansI	{  print_unicode(0xD610); }
\\mitsansJ	{  print_unicode(0xD611); }
\\mitsansK	{  print_unicode(0xD612); }
\\mitsansL	{  print_unicode(0xD613); }
\\mitsansM	{  print_unicode(0xD614); }
\\mitsansN	{  print_unicode(0xD615); }
\\mitsansO	{  print_unicode(0xD616); }
\\mitsansP	{  print_unicode(0xD617); }
\\mitsansQ	{  print_unicode(0xD618); }
\\mitsansR	{  print_unicode(0xD619); }
\\mitsansS	{  print_unicode(0xD61A); }
\\mitsansT	{  print_unicode(0xD61B); }
\\mitsansU	{  print_unicode(0xD61C); }
\\mitsansV	{  print_unicode(0xD61D); }
\\mitsansW	{  print_unicode(0xD61E); }
\\mitsansX	{  print_unicode(0xD61F); }
\\mitsansY	{  print_unicode(0xD620); }
\\mitsansZ	{  print_unicode(0xD621); }
\\mitsansa	{  print_unicode(0xD622); }
\\mitsansb	{  print_unicode(0xD623); }
\\mitsansc	{  print_unicode(0xD624); }
\\mitsansd	{  print_unicode(0xD625); }
\\mitsanse	{  print_unicode(0xD626); }
\\mitsansf	{  print_unicode(0xD627); }
\\mitsansg	{  print_unicode(0xD628); }
\\mitsansh	{  print_unicode(0xD629); }
\\mitsansi	{  print_unicode(0xD62A); }
\\mitsansj	{  print_unicode(0xD62B); }
\\mitsansk	{  print_unicode(0xD62C); }
\\mitsansl	{  print_unicode(0xD62D); }
\\mitsansm	{  print_unicode(0xD62E); }
\\mitsansn	{  print_unicode(0xD62F); }
\\mitsanso	{  print_unicode(0xD630); }
\\mitsansp	{  print_unicode(0xD631); }
\\mitsansq	{  print_unicode(0xD632); }
\\mitsansr	{  print_unicode(0xD633); }
\\mitsanss	{  print_unicode(0xD634); }
\\mitsanst	{  print_unicode(0xD635); }
\\mitsansu	{  print_unicode(0xD636); }
\\mitsansv	{  print_unicode(0xD637); }
\\mitsansw	{  print_unicode(0xD638); }
\\mitsansx	{  print_unicode(0xD639); }
\\mitsansy	{  print_unicode(0xD63A); }
\\mitsansz	{  print_unicode(0xD63B); }
\\mbfitsansA	{  print_unicode(0xD63C); }
\\mbfitsansB	{  print_unicode(0xD63D); }
\\mbfitsansC	{  print_unicode(0xD63E); }
\\mbfitsansD	{  print_unicode(0xD63F); }
\\mbfitsansE	{  print_unicode(0xD640); }
\\mbfitsansF	{  print_unicode(0xD641); }
\\mbfitsansG	{  print_unicode(0xD642); }
\\mbfitsansH	{  print_unicode(0xD643); }
\\mbfitsansI	{  print_unicode(0xD644); }
\\mbfitsansJ	{  print_unicode(0xD645); }
\\mbfitsansK	{  print_unicode(0xD646); }
\\mbfitsansL	{  print_unicode(0xD647); }
\\mbfitsansM	{  print_unicode(0xD648); }
\\mbfitsansN	{  print_unicode(0xD649); }
\\mbfitsansO	{  print_unicode(0xD64A); }
\\mbfitsansP	{  print_unicode(0xD64B); }
\\mbfitsansQ	{  print_unicode(0xD64C); }
\\mbfitsansR	{  print_unicode(0xD64D); }
\\mbfitsansS	{  print_unicode(0xD64E); }
\\mbfitsansT	{  print_unicode(0xD64F); }
\\mbfitsansU	{  print_unicode(0xD650); }
\\mbfitsansV	{  print_unicode(0xD651); }
\\mbfitsansW	{  print_unicode(0xD652); }
\\mbfitsansX	{  print_unicode(0xD653); }
\\mbfitsansY	{  print_unicode(0xD654); }
\\mbfitsansZ	{  print_unicode(0xD655); }
\\mbfitsansa	{  print_unicode(0xD656); }
\\mbfitsansb	{  print_unicode(0xD657); }
\\mbfitsansc	{  print_unicode(0xD658); }
\\mbfitsansd	{  print_unicode(0xD659); }
\\mbfitsanse	{  print_unicode(0xD65A); }
\\mbfitsansf	{  print_unicode(0xD65B); }
\\mbfitsansg	{  print_unicode(0xD65C); }
\\mbfitsansh	{  print_unicode(0xD65D); }
\\mbfitsansi	{  print_unicode(0xD65E); }
\\mbfitsansj	{  print_unicode(0xD65F); }
\\mbfitsansk	{  print_unicode(0xD660); }
\\mbfitsansl	{  print_unicode(0xD661); }
\\mbfitsansm	{  print_unicode(0xD662); }
\\mbfitsansn	{  print_unicode(0xD663); }
\\mbfitsanso	{  print_unicode(0xD664); }
\\mbfitsansp	{  print_unicode(0xD665); }
\\mbfitsansq	{  print_unicode(0xD666); }
\\mbfitsansr	{  print_unicode(0xD667); }
\\mbfitsanss	{  print_unicode(0xD668); }
\\mbfitsanst	{  print_unicode(0xD669); }
\\mbfitsansu	{  print_unicode(0xD66A); }
\\mbfitsansv	{  print_unicode(0xD66B); }
\\mbfitsansw	{  print_unicode(0xD66C); }
\\mbfitsansx	{  print_unicode(0xD66D); }
\\mbfitsansy	{  print_unicode(0xD66E); }
\\mbfitsansz	{  print_unicode(0xD66F); }
\\mttA	{  print_unicode(0xD670); }
\\mttB	{  print_unicode(0xD671); }
\\mttC	{  print_unicode(0xD672); }
\\mttD	{  print_unicode(0xD673); }
\\mttE	{  print_unicode(0xD674); }
\\mttF	{  print_unicode(0xD675); }
\\mttG	{  print_unicode(0xD676); }
\\mttH	{  print_unicode(0xD677); }
\\mttI	{  print_unicode(0xD678); }
\\mttJ	{  print_unicode(0xD679); }
\\mttK	{  print_unicode(0xD67A); }
\\mttL	{  print_unicode(0xD67B); }
\\mttM	{  print_unicode(0xD67C); }
\\mttN	{  print_unicode(0xD67D); }
\\mttO	{  print_unicode(0xD67E); }
\\mttP	{  print_unicode(0xD67F); }
\\mttQ	{  print_unicode(0xD680); }
\\mttR	{  print_unicode(0xD681); }
\\mttS	{  print_unicode(0xD682); }
\\mttT	{  print_unicode(0xD683); }
\\mttU	{  print_unicode(0xD684); }
\\mttV	{  print_unicode(0xD685); }
\\mttW	{  print_unicode(0xD686); }
\\mttX	{  print_unicode(0xD687); }
\\mttY	{  print_unicode(0xD688); }
\\mttZ	{  print_unicode(0xD689); }
\\mtta	{  print_unicode(0xD68A); }
\\mttb	{  print_unicode(0xD68B); }
\\mttc	{  print_unicode(0xD68C); }
\\mttd	{  print_unicode(0xD68D); }
\\mtte	{  print_unicode(0xD68E); }
\\mttf	{  print_unicode(0xD68F); }
\\mttg	{  print_unicode(0xD690); }
\\mtth	{  print_unicode(0xD691); }
\\mtti	{  print_unicode(0xD692); }
\\mttj	{  print_unicode(0xD693); }
\\mttk	{  print_unicode(0xD694); }
\\mttl	{  print_unicode(0xD695); }
\\mttm	{  print_unicode(0xD696); }
\\mttn	{  print_unicode(0xD697); }
\\mtto	{  print_unicode(0xD698); }
\\mttp	{  print_unicode(0xD699); }
\\mttq	{  print_unicode(0xD69A); }
\\mttr	{  print_unicode(0xD69B); }
\\mtts	{  print_unicode(0xD69C); }
\\mttt	{  print_unicode(0xD69D); }
\\mttu	{  print_unicode(0xD69E); }
\\mttv	{  print_unicode(0xD69F); }
\\mttw	{  print_unicode(0xD6A0); }
\\mttx	{  print_unicode(0xD6A1); }
\\mtty	{  print_unicode(0xD6A2); }
\\mttz	{  print_unicode(0xD6A3); }
\\imath	{  print_unicode(0xD6A4); }
\\jmath	{  print_unicode(0xD6A5); }
\\mbfAlpha	{  print_unicode(0xD6A8); }
\\mbfBeta	{  print_unicode(0xD6A9); }
\\mbfGamma	{  print_unicode(0xD6AA); }
\\mbfDelta	{  print_unicode(0xD6AB); }
\\mbfEpsilon	{  print_unicode(0xD6AC); }
\\mbfZeta	{  print_unicode(0xD6AD); }
\\mbfEta	{  print_unicode(0xD6AE); }
\\mbfTheta	{  print_unicode(0xD6AF); }
\\mbfIota	{  print_unicode(0xD6B0); }
\\mbfKappa	{  print_unicode(0xD6B1); }
\\mbfLambda	{  print_unicode(0xD6B2); }
\\mbfMu	{  print_unicode(0xD6B3); }
\\mbfNu	{  print_unicode(0xD6B4); }
\\mbfXi	{  print_unicode(0xD6B5); }
\\mbfOmicron	{  print_unicode(0xD6B6); }
\\mbfPi	{  print_unicode(0xD6B7); }
\\mbfRho	{  print_unicode(0xD6B8); }
\\mbfvarTheta	{  print_unicode(0xD6B9); }
\\mbfSigma	{  print_unicode(0xD6BA); }
\\mbfTau	{  print_unicode(0xD6BB); }
\\mbfUpsilon	{  print_unicode(0xD6BC); }
\\mbfPhi	{  print_unicode(0xD6BD); }
\\mbfChi	{  print_unicode(0xD6BE); }
\\mbfPsi	{  print_unicode(0xD6BF); }
\\mbfOmega	{  print_unicode(0xD6C0); }
\\mbfnabla	{  print_unicode(0xD6C1); }
\\mbfalpha	{  print_unicode(0xD6C2); }
\\mbfbeta	{  print_unicode(0xD6C3); }
\\mbfgamma	{  print_unicode(0xD6C4); }
\\mbfdelta	{  print_unicode(0xD6C5); }
\\mbfvarepsilon	{  print_unicode(0xD6C6); }
\\mbfzeta	{  print_unicode(0xD6C7); }
\\mbfeta	{  print_unicode(0xD6C8); }
\\mbftheta	{  print_unicode(0xD6C9); }
\\mbfiota	{  print_unicode(0xD6CA); }
\\mbfkappa	{  print_unicode(0xD6CB); }
\\mbflambda	{  print_unicode(0xD6CC); }
\\mbfmu	{  print_unicode(0xD6CD); }
\\mbfnu	{  print_unicode(0xD6CE); }
\\mbfxi	{  print_unicode(0xD6CF); }
\\mbfomicron	{  print_unicode(0xD6D0); }
\\mbfpi	{  print_unicode(0xD6D1); }
\\mbfrho	{  print_unicode(0xD6D2); }
\\mbfvarsigma	{  print_unicode(0xD6D3); }
\\mbfsigma	{  print_unicode(0xD6D4); }
\\mbftau	{  print_unicode(0xD6D5); }
\\mbfupsilon	{  print_unicode(0xD6D6); }
\\mbfvarphi	{  print_unicode(0xD6D7); }
\\mbfchi	{  print_unicode(0xD6D8); }
\\mbfpsi	{  print_unicode(0xD6D9); }
\\mbfomega	{  print_unicode(0xD6DA); }
\\mbfpartial	{  print_unicode(0xD6DB); }
\\mbfepsilon	{  print_unicode(0xD6DC); }
\\mbfvartheta	{  print_unicode(0xD6DD); }
\\mbfvarkappa	{  print_unicode(0xD6DE); }
\\mbfphi	{  print_unicode(0xD6DF); }
\\mbfvarrho	{  print_unicode(0xD6E0); }
\\mbfvarpi	{  print_unicode(0xD6E1); }
\\mitAlpha	{  print_unicode(0xD6E2); }
\\mitBeta	{  print_unicode(0xD6E3); }
\\mitGamma	{  print_unicode(0xD6E4); }
\\mitDelta	{  print_unicode(0xD6E5); }
\\mitEpsilon	{  print_unicode(0xD6E6); }
\\mitZeta	{  print_unicode(0xD6E7); }
\\mitEta	{  print_unicode(0xD6E8); }
\\mitTheta	{  print_unicode(0xD6E9); }
\\mitIota	{  print_unicode(0xD6EA); }
\\mitKappa	{  print_unicode(0xD6EB); }
\\mitLambda	{  print_unicode(0xD6EC); }
\\mitMu	{  print_unicode(0xD6ED); }
\\mitNu	{  print_unicode(0xD6EE); }
\\mitXi	{  print_unicode(0xD6EF); }
\\mitOmicron	{  print_unicode(0xD6F0); }
\\mitPi	{  print_unicode(0xD6F1); }
\\mitRho	{  print_unicode(0xD6F2); }
\\mitvarTheta	{  print_unicode(0xD6F3); }
\\mitSigma	{  print_unicode(0xD6F4); }
\\mitTau	{  print_unicode(0xD6F5); }
\\mitUpsilon	{  print_unicode(0xD6F6); }
\\mitPhi	{  print_unicode(0xD6F7); }
\\mitChi	{  print_unicode(0xD6F8); }
\\mitPsi	{  print_unicode(0xD6F9); }
\\mitOmega	{  print_unicode(0xD6FA); }
\\mitnabla	{  print_unicode(0xD6FB); }
\\mitalpha	{  print_unicode(0xD6FC); }
\\mitbeta	{  print_unicode(0xD6FD); }
\\mitgamma	{  print_unicode(0xD6FE); }
\\mitdelta	{  print_unicode(0xD6FF); }
\\mitvarepsilon	{  print_unicode(0xD700); }
\\mitzeta	{  print_unicode(0xD701); }
\\miteta	{  print_unicode(0xD702); }
\\mittheta	{  print_unicode(0xD703); }
\\mitiota	{  print_unicode(0xD704); }
\\mitkappa	{  print_unicode(0xD705); }
\\mitlambda	{  print_unicode(0xD706); }
\\mitmu	{  print_unicode(0xD707); }
\\mitnu	{  print_unicode(0xD708); }
\\mitxi	{  print_unicode(0xD709); }
\\mitomicron	{  print_unicode(0xD70A); }
\\mitpi	{  print_unicode(0xD70B); }
\\mitrho	{  print_unicode(0xD70C); }
\\mitvarsigma	{  print_unicode(0xD70D); }
\\mitsigma	{  print_unicode(0xD70E); }
\\mittau	{  print_unicode(0xD70F); }
\\mitupsilon	{  print_unicode(0xD710); }
\\mitvarphi	{  print_unicode(0xD711); }
\\mitchi	{  print_unicode(0xD712); }
\\mitpsi	{  print_unicode(0xD713); }
\\mitomega	{  print_unicode(0xD714); }
\\mitpartial	{  print_unicode(0xD715); }
\\mitepsilon	{  print_unicode(0xD716); }
\\mitvartheta	{  print_unicode(0xD717); }
\\mitvarkappa	{  print_unicode(0xD718); }
\\mitphi	{  print_unicode(0xD719); }
\\mitvarrho	{  print_unicode(0xD71A); }
\\mitvarpi	{  print_unicode(0xD71B); }
\\mbfitAlpha	{  print_unicode(0xD71C); }
\\mbfitBeta	{  print_unicode(0xD71D); }
\\mbfitGamma	{  print_unicode(0xD71E); }
\\mbfitDelta	{  print_unicode(0xD71F); }
\\mbfitEpsilon	{  print_unicode(0xD720); }
\\mbfitZeta	{  print_unicode(0xD721); }
\\mbfitEta	{  print_unicode(0xD722); }
\\mbfitTheta	{  print_unicode(0xD723); }
\\mbfitIota	{  print_unicode(0xD724); }
\\mbfitKappa	{  print_unicode(0xD725); }
\\mbfitLambda	{  print_unicode(0xD726); }
\\mbfitMu	{  print_unicode(0xD727); }
\\mbfitNu	{  print_unicode(0xD728); }
\\mbfitXi	{  print_unicode(0xD729); }
\\mbfitOmicron	{  print_unicode(0xD72A); }
\\mbfitPi	{  print_unicode(0xD72B); }
\\mbfitRho	{  print_unicode(0xD72C); }
\\mbfitvarTheta	{  print_unicode(0xD72D); }
\\mbfitSigma	{  print_unicode(0xD72E); }
\\mbfitTau	{  print_unicode(0xD72F); }
\\mbfitUpsilon	{  print_unicode(0xD730); }
\\mbfitPhi	{  print_unicode(0xD731); }
\\mbfitChi	{  print_unicode(0xD732); }
\\mbfitPsi	{  print_unicode(0xD733); }
\\mbfitOmega	{  print_unicode(0xD734); }
\\mbfitnabla	{  print_unicode(0xD735); }
\\mbfitalpha	{  print_unicode(0xD736); }
\\mbfitbeta	{  print_unicode(0xD737); }
\\mbfitgamma	{  print_unicode(0xD738); }
\\mbfitdelta	{  print_unicode(0xD739); }
\\mbfitvarepsilon	{  print_unicode(0xD73A); }
\\mbfitzeta	{  print_unicode(0xD73B); }
\\mbfiteta	{  print_unicode(0xD73C); }
\\mbfittheta	{  print_unicode(0xD73D); }
\\mbfitiota	{  print_unicode(0xD73E); }
\\mbfitkappa	{  print_unicode(0xD73F); }
\\mbfitlambda	{  print_unicode(0xD740); }
\\mbfitmu	{  print_unicode(0xD741); }
\\mbfitnu	{  print_unicode(0xD742); }
\\mbfitxi	{  print_unicode(0xD743); }
\\mbfitomicron	{  print_unicode(0xD744); }
\\mbfitpi	{  print_unicode(0xD745); }
\\mbfitrho	{  print_unicode(0xD746); }
\\mbfitvarsigma	{  print_unicode(0xD747); }
\\mbfitsigma	{  print_unicode(0xD748); }
\\mbfittau	{  print_unicode(0xD749); }
\\mbfitupsilon	{  print_unicode(0xD74A); }
\\mbfitvarphi	{  print_unicode(0xD74B); }
\\mbfitchi	{  print_unicode(0xD74C); }
\\mbfitpsi	{  print_unicode(0xD74D); }
\\mbfitomega	{  print_unicode(0xD74E); }
\\mbfitpartial	{  print_unicode(0xD74F); }
\\mbfitepsilon	{  print_unicode(0xD750); }
\\mbfitvartheta	{  print_unicode(0xD751); }
\\mbfitvarkappa	{  print_unicode(0xD752); }
\\mbfitphi	{  print_unicode(0xD753); }
\\mbfitvarrho	{  print_unicode(0xD754); }
\\mbfitvarpi	{  print_unicode(0xD755); }
\\mbfsansAlpha	{  print_unicode(0xD756); }
\\mbfsansBeta	{  print_unicode(0xD757); }
\\mbfsansGamma	{  print_unicode(0xD758); }
\\mbfsansDelta	{  print_unicode(0xD759); }
\\mbfsansEpsilon	{  print_unicode(0xD75A); }
\\mbfsansZeta	{  print_unicode(0xD75B); }
\\mbfsansEta	{  print_unicode(0xD75C); }
\\mbfsansTheta	{  print_unicode(0xD75D); }
\\mbfsansIota	{  print_unicode(0xD75E); }
\\mbfsansKappa	{  print_unicode(0xD75F); }
\\mbfsansLambda	{  print_unicode(0xD760); }
\\mbfsansMu	{  print_unicode(0xD761); }
\\mbfsansNu	{  print_unicode(0xD762); }
\\mbfsansXi	{  print_unicode(0xD763); }
\\mbfsansOmicron	{  print_unicode(0xD764); }
\\mbfsansPi	{  print_unicode(0xD765); }
\\mbfsansRho	{  print_unicode(0xD766); }
\\mbfsansvarTheta	{  print_unicode(0xD767); }
\\mbfsansSigma	{  print_unicode(0xD768); }
\\mbfsansTau	{  print_unicode(0xD769); }
\\mbfsansUpsilon	{  print_unicode(0xD76A); }
\\mbfsansPhi	{  print_unicode(0xD76B); }
\\mbfsansChi	{  print_unicode(0xD76C); }
\\mbfsansPsi	{  print_unicode(0xD76D); }
\\mbfsansOmega	{  print_unicode(0xD76E); }
\\mbfsansnabla	{  print_unicode(0xD76F); }
\\mbfsansalpha	{  print_unicode(0xD770); }
\\mbfsansbeta	{  print_unicode(0xD771); }
\\mbfsansgamma	{  print_unicode(0xD772); }
\\mbfsansdelta	{  print_unicode(0xD773); }
\\mbfsansvarepsilon	{  print_unicode(0xD774); }
\\mbfsanszeta	{  print_unicode(0xD775); }
\\mbfsanseta	{  print_unicode(0xD776); }
\\mbfsanstheta	{  print_unicode(0xD777); }
\\mbfsansiota	{  print_unicode(0xD778); }
\\mbfsanskappa	{  print_unicode(0xD779); }
\\mbfsanslambda	{  print_unicode(0xD77A); }
\\mbfsansmu	{  print_unicode(0xD77B); }
\\mbfsansnu	{  print_unicode(0xD77C); }
\\mbfsansxi	{  print_unicode(0xD77D); }
\\mbfsansomicron	{  print_unicode(0xD77E); }
\\mbfsanspi	{  print_unicode(0xD77F); }
\\mbfsansrho	{  print_unicode(0xD780); }
\\mbfsansvarsigma	{  print_unicode(0xD781); }
\\mbfsanssigma	{  print_unicode(0xD782); }
\\mbfsanstau	{  print_unicode(0xD783); }
\\mbfsansupsilon	{  print_unicode(0xD784); }
\\mbfsansvarphi	{  print_unicode(0xD785); }
\\mbfsanschi	{  print_unicode(0xD786); }
\\mbfsanspsi	{  print_unicode(0xD787); }
\\mbfsansomega	{  print_unicode(0xD788); }
\\mbfsanspartial	{  print_unicode(0xD789); }
\\mbfsansepsilon	{  print_unicode(0xD78A); }
\\mbfsansvartheta	{  print_unicode(0xD78B); }
\\mbfsansvarkappa	{  print_unicode(0xD78C); }
\\mbfsansphi	{  print_unicode(0xD78D); }
\\mbfsansvarrho	{  print_unicode(0xD78E); }
\\mbfsansvarpi	{  print_unicode(0xD78F); }
\\mbfitsansAlpha	{  print_unicode(0xD790); }
\\mbfitsansBeta	{  print_unicode(0xD791); }
\\mbfitsansGamma	{  print_unicode(0xD792); }
\\mbfitsansDelta	{  print_unicode(0xD793); }
\\mbfitsansEpsilon	{  print_unicode(0xD794); }
\\mbfitsansZeta	{  print_unicode(0xD795); }
\\mbfitsansEta	{  print_unicode(0xD796); }
\\mbfitsansTheta	{  print_unicode(0xD797); }
\\mbfitsansIota	{  print_unicode(0xD798); }
\\mbfitsansKappa	{  print_unicode(0xD799); }
\\mbfitsansLambda	{  print_unicode(0xD79A); }
\\mbfitsansMu	{  print_unicode(0xD79B); }
\\mbfitsansNu	{  print_unicode(0xD79C); }
\\mbfitsansXi	{  print_unicode(0xD79D); }
\\mbfitsansOmicron	{  print_unicode(0xD79E); }
\\mbfitsansPi	{  print_unicode(0xD79F); }
\\mbfitsansRho	{  print_unicode(0xD7A0); }
\\mbfitsansvarTheta	{  print_unicode(0xD7A1); }
\\mbfitsansSigma	{  print_unicode(0xD7A2); }
\\mbfitsansTau	{  print_unicode(0xD7A3); }
\\mbfitsansUpsilon	{  print_unicode(0xD7A4); }
\\mbfitsansPhi	{  print_unicode(0xD7A5); }
\\mbfitsansChi	{  print_unicode(0xD7A6); }
\\mbfitsansPsi	{  print_unicode(0xD7A7); }
\\mbfitsansOmega	{  print_unicode(0xD7A8); }
\\mbfitsansnabla	{  print_unicode(0xD7A9); }
\\mbfitsansalpha	{  print_unicode(0xD7AA); }
\\mbfitsansbeta	{  print_unicode(0xD7AB); }
\\mbfitsansgamma	{  print_unicode(0xD7AC); }
\\mbfitsansdelta	{  print_unicode(0xD7AD); }
\\mbfitsansvarepsilon	{  print_unicode(0xD7AE); }
\\mbfitsanszeta	{  print_unicode(0xD7AF); }
\\mbfitsanseta	{  print_unicode(0xD7B0); }
\\mbfitsanstheta	{  print_unicode(0xD7B1); }
\\mbfitsansiota	{  print_unicode(0xD7B2); }
\\mbfitsanskappa	{  print_unicode(0xD7B3); }
\\mbfitsanslambda	{  print_unicode(0xD7B4); }
\\mbfitsansmu	{  print_unicode(0xD7B5); }
\\mbfitsansnu	{  print_unicode(0xD7B6); }
\\mbfitsansxi	{  print_unicode(0xD7B7); }
\\mbfitsansomicron	{  print_unicode(0xD7B8); }
\\mbfitsanspi	{  print_unicode(0xD7B9); }
\\mbfitsansrho	{  print_unicode(0xD7BA); }
\\mbfitsansvarsigma	{  print_unicode(0xD7BB); }
\\mbfitsanssigma	{  print_unicode(0xD7BC); }
\\mbfitsanstau	{  print_unicode(0xD7BD); }
\\mbfitsansupsilon	{  print_unicode(0xD7BE); }
\\mbfitsansvarphi	{  print_unicode(0xD7BF); }
\\mbfitsanschi	{  print_unicode(0xD7C0); }
\\mbfitsanspsi	{  print_unicode(0xD7C1); }
\\mbfitsansomega	{  print_unicode(0xD7C2); }
\\mbfitsanspartial	{  print_unicode(0xD7C3); }
\\mbfitsansepsilon	{  print_unicode(0xD7C4); }
\\mbfitsansvartheta	{  print_unicode(0xD7C5); }
\\mbfitsansvarkappa	{  print_unicode(0xD7C6); }
\\mbfitsansphi	{  print_unicode(0xD7C7); }
\\mbfitsansvarrho	{  print_unicode(0xD7C8); }
\\mbfitsansvarpi	{  print_unicode(0xD7C9); }
\\mbfDigamma	{  print_unicode(0xD7CA); }
\\mbfdigamma	{  print_unicode(0xD7CB); }
\\mbfzero	{  print_unicode(0xD7CE); }
\\mbfone	{  print_unicode(0xD7CF); }
\\mbftwo	{  print_unicode(0xD7D0); }
\\mbfthree	{  print_unicode(0xD7D1); }
\\mbffour	{  print_unicode(0xD7D2); }
\\mbffive	{  print_unicode(0xD7D3); }
\\mbfsix	{  print_unicode(0xD7D4); }
\\mbfseven	{  print_unicode(0xD7D5); }
\\mbfeight	{  print_unicode(0xD7D6); }
\\mbfnine	{  print_unicode(0xD7D7); }
\\Bbbzero	{  print_unicode(0xD7D8); }
\\Bbbone	{  print_unicode(0xD7D9); }
\\Bbbtwo	{  print_unicode(0xD7DA); }
\\Bbbthree	{  print_unicode(0xD7DB); }
\\Bbbfour	{  print_unicode(0xD7DC); }
\\Bbbfive	{  print_unicode(0xD7DD); }
\\Bbbsix	{  print_unicode(0xD7DE); }
\\Bbbseven	{  print_unicode(0xD7DF); }
\\Bbbeight	{  print_unicode(0xD7E0); }
\\Bbbnine	{  print_unicode(0xD7E1); }
\\msanszero	{  print_unicode(0xD7E2); }
\\msansone	{  print_unicode(0xD7E3); }
\\msanstwo	{  print_unicode(0xD7E4); }
\\msansthree	{  print_unicode(0xD7E5); }
\\msansfour	{  print_unicode(0xD7E6); }
\\msansfive	{  print_unicode(0xD7E7); }
\\msanssix	{  print_unicode(0xD7E8); }
\\msansseven	{  print_unicode(0xD7E9); }
\\msanseight	{  print_unicode(0xD7EA); }
\\msansnine	{  print_unicode(0xD7EB); }
\\mbfsanszero	{  print_unicode(0xD7EC); }
\\mbfsansone	{  print_unicode(0xD7ED); }
\\mbfsanstwo	{  print_unicode(0xD7EE); }
\\mbfsansthree	{  print_unicode(0xD7EF); }
\\mbfsansfour	{  print_unicode(0xD7F0); }
\\mbfsansfive	{  print_unicode(0xD7F1); }
\\mbfsanssix	{  print_unicode(0xD7F2); }
\\mbfsansseven	{  print_unicode(0xD7F3); }
\\mbfsanseight	{  print_unicode(0xD7F4); }
\\mbfsansnine	{  print_unicode(0xD7F5); }
\\mttzero	{  print_unicode(0xD7F6); }
\\mttone	{  print_unicode(0xD7F7); }
\\mtttwo	{  print_unicode(0xD7F8); }
\\mttthree	{  print_unicode(0xD7F9); }
\\mttfour	{  print_unicode(0xD7FA); }
\\mttfive	{  print_unicode(0xD7FB); }
\\mttsix	{  print_unicode(0xD7FC); }
\\mttseven	{  print_unicode(0xD7FD); }
\\mtteight	{  print_unicode(0xD7FE); }
\\mttnine	{  print_unicode(0xD7FF); }
\n ;
[0-9]+ ECHO;

*/

